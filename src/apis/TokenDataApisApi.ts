/* tslint:disable */
/* eslint-disable */
/**
 * namaste-be
 * Namaste Server
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  IErrorResponse,
  ITokenData,
  IUpdateTokenData,
  ResponsesResponseIListTokenData,
  ResponsesResponseITokenData,
  ResponsesResponseTokenData,
} from '../models';
import {
    IErrorResponseFromJSON,
    IErrorResponseToJSON,
    ITokenDataFromJSON,
    ITokenDataToJSON,
    IUpdateTokenDataFromJSON,
    IUpdateTokenDataToJSON,
    ResponsesResponseIListTokenDataFromJSON,
    ResponsesResponseIListTokenDataToJSON,
    ResponsesResponseITokenDataFromJSON,
    ResponsesResponseITokenDataToJSON,
    ResponsesResponseTokenDataFromJSON,
    ResponsesResponseTokenDataToJSON,
} from '../models';

export interface CreateTokenDataRequest {
    xApiKey: string;
    iTokenData: ITokenData;
}

export interface GetTokenDataForServerRequest {
    tokenDataId: string;
    xApiKey: string;
}

export interface ListTokenDataRequest {
    xApiKey: string;
    lastId?: string;
    size?: number;
}

export interface UpdateTokenDataRequest {
    xApiKey: string;
    iUpdateTokenData: IUpdateTokenData;
}

/**
 * TokenDataApisApi - interface
 * 
 * @export
 * @interface TokenDataApisApiInterface
 */
export interface TokenDataApisApiInterface {
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {ITokenData} iTokenData - ITokenData - This is the request body that is sent to the API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenDataApisApiInterface
     */
    createTokenDataRaw(requestParameters: CreateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseTokenData>>;

    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     */
    createTokenData(requestParameters: CreateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseTokenData>;

    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} tokenDataId - The id of the token data you want to retrieve.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenDataApisApiInterface
     */
    getTokenDataForServerRaw(requestParameters: GetTokenDataForServerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseITokenData>>;

    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     */
    getTokenDataForServer(requestParameters: GetTokenDataForServerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseITokenData>;

    /**
     * It lists all the token data for a company.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {string} [lastId] - The last id of the last token data that was returned. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenDataApisApiInterface
     */
    listTokenDataRaw(requestParameters: ListTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseIListTokenData>>;

    /**
     * It lists all the token data for a company.
     */
    listTokenData(requestParameters: ListTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseIListTokenData>;

    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {IUpdateTokenData} iUpdateTokenData - IUpdateTokenData - This is the request body that is sent to the API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenDataApisApiInterface
     */
    updateTokenDataRaw(requestParameters: UpdateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseTokenData>>;

    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     */
    updateTokenData(requestParameters: UpdateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseTokenData>;

}

/**
 * 
 */
export class TokenDataApisApi extends runtime.BaseAPI implements TokenDataApisApiInterface {

    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     */
    async createTokenDataRaw(requestParameters: CreateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseTokenData>> {
        if (requestParameters.xApiKey === null || requestParameters.xApiKey === undefined) {
            throw new runtime.RequiredError('xApiKey','Required parameter requestParameters.xApiKey was null or undefined when calling createTokenData.');
        }

        if (requestParameters.iTokenData === null || requestParameters.iTokenData === undefined) {
            throw new runtime.RequiredError('iTokenData','Required parameter requestParameters.iTokenData was null or undefined when calling createTokenData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xApiKey !== undefined && requestParameters.xApiKey !== null) {
            headerParameters['x-api-key'] = String(requestParameters.xApiKey);
        }

        const response = await this.request({
            path: `/token-data/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ITokenDataToJSON(requestParameters.iTokenData),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponsesResponseTokenDataFromJSON(jsonValue));
    }

    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     */
    async createTokenData(requestParameters: CreateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseTokenData> {
        const response = await this.createTokenDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     */
    async getTokenDataForServerRaw(requestParameters: GetTokenDataForServerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseITokenData>> {
        if (requestParameters.tokenDataId === null || requestParameters.tokenDataId === undefined) {
            throw new runtime.RequiredError('tokenDataId','Required parameter requestParameters.tokenDataId was null or undefined when calling getTokenDataForServer.');
        }

        if (requestParameters.xApiKey === null || requestParameters.xApiKey === undefined) {
            throw new runtime.RequiredError('xApiKey','Required parameter requestParameters.xApiKey was null or undefined when calling getTokenDataForServer.');
        }

        const queryParameters: any = {};

        if (requestParameters.tokenDataId !== undefined) {
            queryParameters['tokenDataId'] = requestParameters.tokenDataId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xApiKey !== undefined && requestParameters.xApiKey !== null) {
            headerParameters['x-api-key'] = String(requestParameters.xApiKey);
        }

        const response = await this.request({
            path: `/token-data/get`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponsesResponseITokenDataFromJSON(jsonValue));
    }

    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     */
    async getTokenDataForServer(requestParameters: GetTokenDataForServerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseITokenData> {
        const response = await this.getTokenDataForServerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * It lists all the token data for a company.
     */
    async listTokenDataRaw(requestParameters: ListTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseIListTokenData>> {
        if (requestParameters.xApiKey === null || requestParameters.xApiKey === undefined) {
            throw new runtime.RequiredError('xApiKey','Required parameter requestParameters.xApiKey was null or undefined when calling listTokenData.');
        }

        const queryParameters: any = {};

        if (requestParameters.lastId !== undefined) {
            queryParameters['lastId'] = requestParameters.lastId;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xApiKey !== undefined && requestParameters.xApiKey !== null) {
            headerParameters['x-api-key'] = String(requestParameters.xApiKey);
        }

        const response = await this.request({
            path: `/token-data/list`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponsesResponseIListTokenDataFromJSON(jsonValue));
    }

    /**
     * It lists all the token data for a company.
     */
    async listTokenData(requestParameters: ListTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseIListTokenData> {
        const response = await this.listTokenDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     */
    async updateTokenDataRaw(requestParameters: UpdateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponseTokenData>> {
        if (requestParameters.xApiKey === null || requestParameters.xApiKey === undefined) {
            throw new runtime.RequiredError('xApiKey','Required parameter requestParameters.xApiKey was null or undefined when calling updateTokenData.');
        }

        if (requestParameters.iUpdateTokenData === null || requestParameters.iUpdateTokenData === undefined) {
            throw new runtime.RequiredError('iUpdateTokenData','Required parameter requestParameters.iUpdateTokenData was null or undefined when calling updateTokenData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xApiKey !== undefined && requestParameters.xApiKey !== null) {
            headerParameters['x-api-key'] = String(requestParameters.xApiKey);
        }

        const response = await this.request({
            path: `/token-data/update`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IUpdateTokenDataToJSON(requestParameters.iUpdateTokenData),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponsesResponseTokenDataFromJSON(jsonValue));
    }

    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     */
    async updateTokenData(requestParameters: UpdateTokenDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponseTokenData> {
        const response = await this.updateTokenDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
