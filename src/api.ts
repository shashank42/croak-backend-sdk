
// import * as custom from './custom';
// / <reference path="./custom.d.ts" />
// tslint:disable
/**
 * namaste-be
 * Namaste Server
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as isomorphicFetch from 'isomorphic-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'https://be.namasteapis.com/blockchain/v1'.replace(/\/+$/, '');

type ModelObject = any;

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration!: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name!: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @enum {string}
 */
export enum AssetContractTypeEnum {
  OpenGlipERC1155 = <any>'OpenGlipERC1155',
  GlipLiveERC721 = <any>'GlipLiveERC721',
  GlipPassERC1155 = <any>'GlipPassERC1155',
  ERC20 = <any>'ERC20',
  NONE = <any>'NONE',
}
/**
 *
 * @export
 */
export type Company = ModelObject;
/**
 *
 * @export
 */
export type CryptoWallet = ModelObject;
/**
 *
 * @export
 * @interface IContract
 */
export interface IContract {
  /**
   *
   * @type {Company}
   * @memberof IContract
   */
  company?: Company;
  /**
   *
   * @type {AssetContractTypeEnum}
   * @memberof IContract
   */
  type: AssetContractTypeEnum;
  /**
   *
   * @type {NetworkEnum}
   * @memberof IContract
   */
  chain: NetworkEnum;
  /**
   * Name of the contract. This will help you identify it later. This is also committed to the blockchain.
   * @type {string}
   * @memberof IContract
   */
  name: string;
  /**
   * The symbol of the contract. This is also committed to the blockchain. The tokens from this contract will have this symbol. eg. BAYC token
   * @type {string}
   * @memberof IContract
   */
  symbol: string;
  /**
   * The description of the contract. Any string will do.
   * @type {string}
   * @memberof IContract
   */
  description: string;
  /**
   * The url of the image for the collection which this contract represents. Part of the contract metadata.
   * @type {string}
   * @memberof IContract
   */
  image: string;
  /**
   * The url of the website/video/etc for the collection which this contract represents. Part of the contract metadata.
   * @type {string}
   * @memberof IContract
   */
  externalUrl: string;
  /**
   * List of key value pairs that will add to the contract metadata.
   * @type {Array<Media>}
   * @memberof IContract
   */
  media: Array<Media>;
}
/**
 *
 * @export
 * @interface ICreateBuyOrder
 */
export interface ICreateBuyOrder {
  /**
   *
   * @type {Company}
   * @memberof ICreateBuyOrder
   */
  company?: Company;
  /**
   *
   * @type {CryptoWallet}
   * @memberof ICreateBuyOrder
   */
  walletFrom?: CryptoWallet;
  /**
   * The id of the sell order that you are buying.
   * @type {string}
   * @memberof ICreateBuyOrder
   */
  sellOrderId?: string;
  /**
   * The walletId of the wallet that is going to authorize and pay to buy the token which is on sale.
   * @type {string}
   * @memberof ICreateBuyOrder
   */
  makerWalletId: string;
  /**
   * The walletId of the wallet that is going to receive the tokens in token being bought.
   * @type {string}
   * @memberof ICreateBuyOrder
   */
  takerWalletId?: string;
  /**
   * The id of the tokenData that is being sent to the seller in to buy the token being offered.
   * @type {string}
   * @memberof ICreateBuyOrder
   */
  makeTokenDataId: string;
  /**
   * The number of tokens of makeTokenDataId that you are sending to the seller.
   * @type {number}
   * @memberof ICreateBuyOrder
   */
  makeAmount: number;
  /**
   * The id of the tokenData that is being bought.
   * @type {string}
   * @memberof ICreateBuyOrder
   */
  takeTokenDataId: string;
  /**
   * The number of tokens (of takeTokenDataId) that you are buying.
   * @type {number}
   * @memberof ICreateBuyOrder
   */
  takeAmount: number;
}
/**
 *
 * @export
 * @interface ICreateCompany
 */
export interface ICreateCompany {
  /**
   * Name of the client. This will help you identify it later.
   * @type {string}
   * @memberof ICreateCompany
   */
  name: string;
  /**
   * The name of the person of contact for the client. This person is also the recipient of the proceeds from primary sale and royalty from secondary sales.
   * @type {string}
   * @memberof ICreateCompany
   */
  poc: string;
  /**
   * The email of the person of contact for the client. This wallet linked to this email will be used to credit the proceeds from primary sale and royalty from secondary sales.
   * @type {string}
   * @memberof ICreateCompany
   */
  pocEmail: string;
}
/**
 *
 * @export
 * @interface ICreateMintSellOrder
 */
export interface ICreateMintSellOrder {
  /**
   *
   * @type {Company}
   * @memberof ICreateMintSellOrder
   */
  company?: Company;
  /**
   * The tokenDataId of the tokenData that is to be sold. The reserve price (minimum price) will be picked from the tokenData itself. GET on the tokenData to get all the information.
   * @type {string}
   * @memberof ICreateMintSellOrder
   */
  tokenDataId: string;
  /**
   * The number of tokens that you want in exchange for selling this tokenData. It is the number of reserveTokenDataId tokens that you are pricing the sale at. GET on the tokenData to get the value of the reserveTokenDataId.
   * @type {number}
   * @memberof ICreateMintSellOrder
   */
  takeAmount: number;
}
/**
 *
 * @export
 * @interface ICreateSellOrder
 */
export interface ICreateSellOrder {
  /**
   *
   * @type {Company}
   * @memberof ICreateSellOrder
   */
  company?: Company;
  /**
   *
   * @type {CryptoWallet}
   * @memberof ICreateSellOrder
   */
  walletFrom?: CryptoWallet;
  /**
   * The wallet id which owns the token that is going to be sold. This is the wallet that will approve the sell order.
   * @type {string}
   * @memberof ICreateSellOrder
   */
  makerWalletId: string;
  /**
   * The wallet id which will receive the tokens in exchange for the token being sold (proceeds from the sale). So one user can sell and another can receive the proceeds.If it is not provided, will assume the value in makerWalletId.
   * @type {string}
   * @memberof ICreateSellOrder
   */
  takerWalletId?: string;
  /**
   * The tokenDataId of the tokenData that is to be sold. GET on the tokenData to get all the information.
   * @type {string}
   * @memberof ICreateSellOrder
   */
  makeTokenDataId: string;
  /**
   * The number of tokens of makeTokenDataId that you are selling in this sell order.
   * @type {number}
   * @memberof ICreateSellOrder
   */
  makeAmount: number;
  /**
   * The tokenDataId being expected in return during the sale. GET on the tokenData to get all the information.
   * @type {string}
   * @memberof ICreateSellOrder
   */
  takeTokenDataId: string;
  /**
   * The number of tokens of takeTokenDataId that you are expecting in return during the sale.
   * @type {number}
   * @memberof ICreateSellOrder
   */
  takeAmount: number;
  /**
   *
   * @type {MarketPlaceOrderTypesEnum}
   * @memberof ICreateSellOrder
   */
  type?: MarketPlaceOrderTypesEnum;
}
/**
 *
 * @export
 * @interface ICreateTokenTransfer
 */
export interface ICreateTokenTransfer {
  /**
   *
   * @type {Company}
   * @memberof ICreateTokenTransfer
   */
  company?: Company;
  /**
   *
   * @type {CryptoWallet}
   * @memberof ICreateTokenTransfer
   */
  walletFrom?: CryptoWallet;
  /**
   *
   * @type {string}
   * @memberof ICreateTokenTransfer
   */
  walletIdFrom: string;
  /**
   *
   * @type {string}
   * @memberof ICreateTokenTransfer
   */
  walletIdTo: string;
  /**
   *
   * @type {string}
   * @memberof ICreateTokenTransfer
   */
  tokenDataId: string;
  /**
   *
   * @type {number}
   * @memberof ICreateTokenTransfer
   */
  amount: number;
}
/**
 *
 * @export
 * @interface ICreateTokenTransferResp
 */
export interface ICreateTokenTransferResp {
  /**
   *
   * @type {string}
   * @memberof ICreateTokenTransferResp
   */
  form: string;
  /**
   *
   * @type {string}
   * @memberof ICreateTokenTransferResp
   */
  chain: string;
}
/**
 *
 * @export
 * @interface IErrorResponse
 */
export interface IErrorResponse {
  /**
   *
   * @type {boolean}
   * @memberof IErrorResponse
   */
  thrown?: boolean;
  /**
   *
   * @type {string}
   * @memberof IErrorResponse
   */
  error?: string;
  /**
   *
   * @type {string}
   * @memberof IErrorResponse
   */
  message?: string;
}
/**
 *
 * @export
 * @interface IGetTokenGroupDataResp
 */
export interface IGetTokenGroupDataResp {
  /**
   *
   * @type {TokenGroupData}
   * @memberof IGetTokenGroupDataResp
   */
  tokenGroup: TokenGroupData;
}
/**
 *
 * @export
 * @interface IGetWalletResp
 */
export interface IGetWalletResp {
  /**
   *
   * @type {Array<CryptoWallet>}
   * @memberof IGetWalletResp
   */
  wallets: Array<CryptoWallet>;
  /**
   *
   * @type {string}
   * @memberof IGetWalletResp
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface IListBuyOrdersDataResp
 */
export interface IListBuyOrdersDataResp {
  /**
   *
   * @type {Array<ResponseBuyOrder>}
   * @memberof IListBuyOrdersDataResp
   */
  buyOrders: Array<ResponseBuyOrder>;
  /**
   *
   * @type {string}
   * @memberof IListBuyOrdersDataResp
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface IListSellOrdersDataResp
 */
export interface IListSellOrdersDataResp {
  /**
   *
   * @type {Array<ResponseSellOrder>}
   * @memberof IListSellOrdersDataResp
   */
  sellOrders: Array<ResponseSellOrder>;
  /**
   *
   * @type {string}
   * @memberof IListSellOrdersDataResp
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface IListTokenGroupDataResp
 */
export interface IListTokenGroupDataResp {
  /**
   *
   * @type {Array<TokenGroupData>}
   * @memberof IListTokenGroupDataResp
   */
  tokenGroups: Array<TokenGroupData>;
  /**
   *
   * @type {string}
   * @memberof IListTokenGroupDataResp
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface IMintData
 */
export interface IMintData {
  /**
   *
   * @type {Company}
   * @memberof IMintData
   */
  company?: Company;
  /**
   * The tokenDataId of the tokenData to mint.
   * @type {string}
   * @memberof IMintData
   */
  tokenDataId: string;
  /**
   * The array of walletIds to mint the tokens into.
   * @type {Array<string>}
   * @memberof IMintData
   */
  destinations: Array<string>;
  /**
   * The array of amount of tokens to mint to the destination wallets.
   * @type {Array<number>}
   * @memberof IMintData
   */
  amounts?: Array<number>;
}
/**
 *
 * @export
 * @interface IMintTokenGroupData
 */
export interface IMintTokenGroupData {
  /**
   *
   * @type {Company}
   * @memberof IMintTokenGroupData
   */
  company?: Company;
  /**
   *
   * @type {string}
   * @memberof IMintTokenGroupData
   */
  tokenGroupDataId: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IMintTokenGroupData
   */
  destinations: Array<string>;
  /**
   *
   * @type {Array<number>}
   * @memberof IMintTokenGroupData
   */
  amounts?: Array<number>;
}
/**
 *
 * @export
 * @interface IRefreshToken
 */
export interface IRefreshToken {
  /**
   *
   * @type {Company}
   * @memberof IRefreshToken
   */
  company?: Company;
  /**
   * Refresh token stored in the client's front-end
   * @type {string}
   * @memberof IRefreshToken
   */
  token: string;
}
/**
 *
 * @export
 * @interface IRefreshTokenResponse
 */
export interface IRefreshTokenResponse {
  /**
   *
   * @type {string}
   * @memberof IRefreshTokenResponse
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof IRefreshTokenResponse
   */
  accessToken: string;
  /**
   *
   * @type {string}
   * @memberof IRefreshTokenResponse
   */
  refreshToken: string;
}
/**
 *
 * @export
 * @interface ISignMarketplaceOrderString
 */
export interface ISignMarketplaceOrderString {
  /**
   *
   * @type {string}
   * @memberof ISignMarketplaceOrderString
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ISignMarketplaceOrderString
   */
  form: string;
}
/**
 *
 * @export
 * @interface ISignatureResponse
 */
export interface ISignatureResponse {
  /**
   *
   * @type {string}
   * @memberof ISignatureResponse
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ISignatureResponse
   */
  signature: string;
  /**
   *
   * @type {CryptoWallet}
   * @memberof ISignatureResponse
   */
  walletFrom?: CryptoWallet;
}
/**
 *
 * @export
 * @interface ISubmitBuyOrderResponse
 */
export interface ISubmitBuyOrderResponse {
  /**
   *
   * @type {string}
   * @memberof ISubmitBuyOrderResponse
   */
  txHash: string;
  /**
   *
   * @type {ResponseNFTMintSale}
   * @memberof ISubmitBuyOrderResponse
   */
  token: ResponseNFTMintSale;
}
/**
 *
 * @export
 * @interface ISubmitTokenTransferResp
 */
export interface ISubmitTokenTransferResp {
  /**
   *
   * @type {string}
   * @memberof ISubmitTokenTransferResp
   */
  txHash: string;
}
/**
 *
 * @export
 * @interface ISubmitTokenTransferString
 */
export interface ISubmitTokenTransferString {
  /**
   *
   * @type {CryptoWallet}
   * @memberof ISubmitTokenTransferString
   */
  walletFrom?: CryptoWallet;
  /**
   *
   * @type {string}
   * @memberof ISubmitTokenTransferString
   */
  chain: string;
  /**
   *
   * @type {string}
   * @memberof ISubmitTokenTransferString
   */
  form: string;
  /**
   *
   * @type {string}
   * @memberof ISubmitTokenTransferString
   */
  signature: string;
}
/**
 *
 * @export
 * @interface ITokenData
 */
export interface ITokenData {
  /**
   *
   * @type {Company}
   * @memberof ITokenData
   */
  company?: Company;
  /**
   *
   * @type {number}
   * @memberof ITokenData
   */
  supply: number;
  /**
   *
   * @type {string}
   * @memberof ITokenData
   */
  reserveTokenDataId: string;
  /**
   *
   * @type {number}
   * @memberof ITokenData
   */
  reserveTokenDataAmount: number;
  /**
   *
   * @type {ModelObject}
   * @memberof ITokenData
   */
  assetContractId: ModelObject;
  /**
   *
   * @type {ITokenMetadata | ITokenExternalMetadataUri}
   * @memberof ITokenData
   */
  metadata: ITokenMetadata | ITokenExternalMetadataUri;
}
/**
 *
 * @export
 * @interface ITokenExternalMetadataUri
 */
export interface ITokenExternalMetadataUri {
  /**
   *
   * @type {string}
   * @memberof ITokenExternalMetadataUri
   */
  url: string;
}
/**
 *
 * @export
 * @interface ITokenGroupData
 */
export interface ITokenGroupData {
  /**
   *
   * @type {Company}
   * @memberof ITokenGroupData
   */
  company?: Company;
  /**
   *
   * @type {string}
   * @memberof ITokenGroupData
   */
  assetContractId: string;
  /**
   *
   * @type {string}
   * @memberof ITokenGroupData
   */
  reserveTokenDataId: string;
  /**
   *
   * @type {number}
   * @memberof ITokenGroupData
   */
  reserveTokenDataAmount: number;
  /**
   *
   * @type {ITokenMetadata | ITokenExternalMetadataUri}
   * @memberof ITokenGroupData
   */
  metadata: ITokenMetadata | ITokenExternalMetadataUri;
}
/**
 *
 * @export
 * @interface ITokenMetadata
 */
export interface ITokenMetadata {
  /**
   *
   * @type {string}
   * @memberof ITokenMetadata
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ITokenMetadata
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ITokenMetadata
   */
  image?: string;
  /**
   *
   * @type {string}
   * @memberof ITokenMetadata
   */
  externalUrl?: string;
  /**
   *
   * @type {string}
   * @memberof ITokenMetadata
   */
  animationUrl?: string;
  /**
   *
   * @type {ModelObject}
   * @memberof ITokenMetadata
   */
  attributes?: ModelObject;
}
/**
 *
 * @export
 * @interface IUpdateTokenData
 */
export interface IUpdateTokenData {
  /**
   *
   * @type {Company}
   * @memberof IUpdateTokenData
   */
  company?: Company;
  /**
   *
   * @type {string}
   * @memberof IUpdateTokenData
   */
  tokenDataId: string;
  /**
   *
   * @type {ITokenMetadata | ITokenExternalMetadataUri}
   * @memberof IUpdateTokenData
   */
  metadata: ITokenMetadata | ITokenExternalMetadataUri;
}
/**
 *
 * @export
 * @interface IUpdateTokenGroupData
 */
export interface IUpdateTokenGroupData {
  /**
   *
   * @type {Company}
   * @memberof IUpdateTokenGroupData
   */
  company?: Company;
  /**
   *
   * @type {string}
   * @memberof IUpdateTokenGroupData
   */
  tokenGroupDataId: string;
  /**
   *
   * @type {string}
   * @memberof IUpdateTokenGroupData
   */
  reserveTokenDataId: string;
  /**
   *
   * @type {number}
   * @memberof IUpdateTokenGroupData
   */
  reserveTokenDataAmount: number;
  /**
   *
   * @type {ITokenMetadata | ITokenExternalMetadataUri}
   * @memberof IUpdateTokenGroupData
   */
  metadata: ITokenMetadata | ITokenExternalMetadataUri;
}
/**
 *
 * @export
 * @interface IVerifyToken
 */
export interface IVerifyToken {
  /**
   *
   * @type {Company}
   * @memberof IVerifyToken
   */
  company?: Company;
  /**
   * Wallet id of the user you want to link to your client. The user must first have logged in using the Wallet SDK initialized with your companyId.
   * @type {string}
   * @memberof IVerifyToken
   */
  walletId: string;
}
/**
 *
 * @export
 * @interface IWallet
 */
export interface IWallet {
  /**
   *
   * @type {Company}
   * @memberof IWallet
   */
  company?: Company;
  /**
   *
   * @type {string}
   * @memberof IWallet
   */
  email: string;
}
/**
 *
 * @export
 * @interface IWalletAuth
 */
export interface IWalletAuth {
  /**
   * Signed access token from the user's wallet
   * @type {string}
   * @memberof IWalletAuth
   */
  signature: string;
  /**
   * Access token returned from the social login provider, eg. google, twitter, etc.
   * @type {string}
   * @memberof IWalletAuth
   */
  accessToken: string;
  /**
   * Verifier of the social login provider, eg. google, twitter, etc.
   * @type {string}
   * @memberof IWalletAuth
   */
  verifier: string;
  /**
   * The company id used to initialize the wallet on the client's front end.
   * @type {string}
   * @memberof IWalletAuth
   */
  companyId?: string;
}
/**
 *
 * @export
 * @interface IWalletAuthResponse
 */
export interface IWalletAuthResponse {
  /**
   *
   * @type {string}
   * @memberof IWalletAuthResponse
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof IWalletAuthResponse
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof IWalletAuthResponse
   */
  accessToken: string;
  /**
   *
   * @type {string}
   * @memberof IWalletAuthResponse
   */
  refreshToken: string;
}
/**
 *
 * @export
 * @interface IWalletCustomAuth
 */
export interface IWalletCustomAuth {
  /**
   *
   * @type {string}
   * @memberof IWalletCustomAuth
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof IWalletCustomAuth
   */
  password: string;
}
/**
 *
 * @export
 * @interface IWalletLoginResponse
 */
export interface IWalletLoginResponse {
  /**
   *
   * @type {CryptoWallet}
   * @memberof IWalletLoginResponse
   */
  wallet: CryptoWallet;
  /**
   *
   * @type {string}
   * @memberof IWalletLoginResponse
   */
  accessToken: string;
}
/**
 *
 * @export
 * @interface IWalletResetPassword
 */
export interface IWalletResetPassword {
  /**
   *
   * @type {string}
   * @memberof IWalletResetPassword
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof IWalletResetPassword
   */
  token: string;
}
/**
 *
 * @export
 * @interface IWalletSign
 */
export interface IWalletSign {
  /**
   *
   * @type {Company}
   * @memberof IWalletSign
   */
  company?: Company;
  /**
   *
   * @type {string}
   * @memberof IWalletSign
   */
  walletId: string;
  /**
   *
   * @type {string}
   * @memberof IWalletSign
   */
  message: string;
}
/**
 *
 * @export
 * @interface IWalletTypedSign
 */
export interface IWalletTypedSign {
  /**
   *
   * @type {Company}
   * @memberof IWalletTypedSign
   */
  company?: Company;
  /**
   *
   * @type {string}
   * @memberof IWalletTypedSign
   */
  walletId: string;
  /**
   *
   * @type {string}
   * @memberof IWalletTypedSign
   */
  domainName: string;
  /**
   *
   * @type {string}
   * @memberof IWalletTypedSign
   */
  domainVersion: string;
  /**
   *
   * @type {number}
   * @memberof IWalletTypedSign
   */
  chainId: number;
  /**
   *
   * @type {string}
   * @memberof IWalletTypedSign
   */
  contractAddress: string;
  /**
   *
   * @type {string}
   * @memberof IWalletTypedSign
   */
  primaryType: string;
  /**
   *
   * @type {ModelObject}
   * @memberof IWalletTypedSign
   */
  types: ModelObject;
  /**
   *
   * @type {ModelObject}
   * @memberof IWalletTypedSign
   */
  form: ModelObject;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum MarketPlaceOrderTypesEnum {
  ENGLISHAUCTION = <any>'ENGLISH_AUCTION',
  NONE = <any>'NONE',
  DIRECTSALE = <any>'DIRECT_SALE',
  MINTDIRECTSALE = <any>'MINT_DIRECT_SALE',
}
/**
 *
 * @export
 * @interface Media
 */
export interface Media {
  /**
   *
   * @type {string}
   * @memberof Media
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof Media
   */
  value: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum NetworkEnum {
  Mumbai = <any>'mumbai',
  Matic = <any>'matic',
  Localhost = <any>'localhost',
}
/**
 * A class representation of the BSON ObjectId type.
 * @export
 */
export type ObjectId = string;
/**
 *
 * @export
 * @interface ResponseBuyOrder
 */
export interface ResponseBuyOrder {
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  makerWalletId: string;
  /**
   *
   * @type {WalletType}
   * @memberof ResponseBuyOrder
   */
  makerWalletType: WalletType;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  takerWalletId: string;
  /**
   *
   * @type {WalletType}
   * @memberof ResponseBuyOrder
   */
  takerWalletType: WalletType;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  companyId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  makeTokenDataId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  takeTokenDataId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  sellOrderId?: string;
  /**
   *
   * @type {number}
   * @memberof ResponseBuyOrder
   */
  makeAmount: number;
  /**
   *
   * @type {number}
   * @memberof ResponseBuyOrder
   */
  takeAmount: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  status: string;
  /**
   *
   * @type {MarketPlaceOrderTypesEnum}
   * @memberof ResponseBuyOrder
   */
  type: MarketPlaceOrderTypesEnum;
  /**
   *
   * @type {boolean}
   * @memberof ResponseBuyOrder
   */
  isClaimed: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  exchangeContract: string;
  /**
   *
   * @type {number}
   * @memberof ResponseBuyOrder
   */
  startTime: number;
  /**
   *
   * @type {number}
   * @memberof ResponseBuyOrder
   */
  endTime: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  signature: string;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  transactionHash: string;
  /**
   *
   * @type {string}
   * @memberof ResponseBuyOrder
   */
  id: string;
}
/**
 *
 * @export
 * @interface ResponseCompany
 */
export interface ResponseCompany {
  /**
   *
   * @type {string}
   * @memberof ResponseCompany
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ResponseCompany
   */
  apiKey: string;
  /**
   *
   * @type {string}
   * @memberof ResponseCompany
   */
  poc: string;
  /**
   *
   * @type {string}
   * @memberof ResponseCompany
   */
  pocEmail: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponseCompany
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseCompany
   */
  pocWalletId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseCompany
   */
  minterWalletId: string;
  /**
   *
   * @type {ModelObject}
   * @memberof ResponseCompany
   */
  testErc20TokenDataIds: ModelObject;
  /**
   *
   * @type {string}
   * @memberof ResponseCompany
   */
  id: string;
}
/**
 *
 * @export
 * @interface ResponseContract
 */
export interface ResponseContract {
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  symbol: string;
  /**
   *
   * @type {NetworkEnum}
   * @memberof ResponseContract
   */
  chain: NetworkEnum;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  externalUrl: string;
  /**
   *
   * @type {AssetContractTypeEnum}
   * @memberof ResponseContract
   */
  type: AssetContractTypeEnum;
  /**
   *
   * @type {Array<Media>}
   * @memberof ResponseContract
   */
  media: Array<Media>;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  contractAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  transactionHash?: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponseContract
   */
  confirmed?: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  deployer: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  factory: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  owner: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  creatorId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseContract
   */
  id: string;
}
/**
 *
 * @export
 * @interface ResponseCryptoWallet
 */
export interface ResponseCryptoWallet {
  /**
   *
   * @type {Array<string>}
   * @memberof ResponseCryptoWallet
   */
  companyId: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ResponseCryptoWallet
   */
  tentativeCompanyId: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ResponseCryptoWallet
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof ResponseCryptoWallet
   */
  publicAddress?: string;
  /**
   *
   * @type {string}
   * @memberof ResponseCryptoWallet
   */
  password?: string;
  /**
   *
   * @type {WalletRegistrationStatus}
   * @memberof ResponseCryptoWallet
   */
  status: WalletRegistrationStatus;
  /**
   *
   * @type {string}
   * @memberof ResponseCryptoWallet
   */
  id: string;
}
/**
 *
 * @export
 * @interface ResponseIGetWallet
 */
export interface ResponseIGetWallet {
  /**
   *
   * @type {Array<ResponseCryptoWallet>}
   * @memberof ResponseIGetWallet
   */
  wallets: Array<ResponseCryptoWallet>;
  /**
   *
   * @type {string}
   * @memberof ResponseIGetWallet
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface ResponseIListContracts
 */
export interface ResponseIListContracts {
  /**
   *
   * @type {Array<ResponseContract>}
   * @memberof ResponseIListContracts
   */
  contracts: Array<ResponseContract>;
  /**
   *
   * @type {string}
   * @memberof ResponseIListContracts
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface ResponseIListTokenData
 */
export interface ResponseIListTokenData {
  /**
   *
   * @type {Array<ResponseTokenData>}
   * @memberof ResponseIListTokenData
   */
  tokens: Array<ResponseTokenData>;
  /**
   *
   * @type {string}
   * @memberof ResponseIListTokenData
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface ResponseIListUsersTokens
 */
export interface ResponseIListUsersTokens {
  /**
   *
   * @type {Array<ResponseContract>}
   * @memberof ResponseIListUsersTokens
   */
  contracts: Array<ResponseContract>;
  /**
   *
   * @type {Array<ResponseListOwnedNFTElement>}
   * @memberof ResponseIListUsersTokens
   */
  nfts: Array<ResponseListOwnedNFTElement>;
  /**
   *
   * @type {string}
   * @memberof ResponseIListUsersTokens
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface ResponseITokenData
 */
export interface ResponseITokenData {
  /**
   *
   * @type {ResponseTokenData}
   * @memberof ResponseITokenData
   */
  token: ResponseTokenData;
  /**
   *
   * @type {string}
   * @memberof ResponseITokenData
   */
  lastId: string;
}
/**
 *
 * @export
 * @interface ResponseListOwnedNFTElement
 */
export interface ResponseListOwnedNFTElement {
  /**
   *
   * @type {ResponseTokenData}
   * @memberof ResponseListOwnedNFTElement
   */
  token: ResponseTokenData;
  /**
   *
   * @type {string}
   * @memberof ResponseListOwnedNFTElement
   */
  quantity: string;
}
/**
 *
 * @export
 * @interface ResponseNFTMintSale
 */
export interface ResponseNFTMintSale {
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  creatorId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  tokenDataId: string;
  /**
   *
   * @type {number}
   * @memberof ResponseNFTMintSale
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  error: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  exchangeContract: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  mintSaleType: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponseNFTMintSale
   */
  minted: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  mintTxId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  mintTxStatus: string;
  /**
   *
   * @type {Date}
   * @memberof ResponseNFTMintSale
   */
  mintedAt: Date;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  mintedPrice: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  mintedCurrency: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  mintedTo: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  mintedToGlipUserId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  auctioneer: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponseNFTMintSale
   */
  cancelled: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ResponseNFTMintSale
   */
  isClaimed: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  claimedByAddress: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  claimTxHash: string;
  /**
   *
   * @type {string}
   * @memberof ResponseNFTMintSale
   */
  id: string;
}
/**
 *
 * @export
 * @interface ResponseSellOrder
 */
export interface ResponseSellOrder {
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  makerWalletId: string;
  /**
   *
   * @type {WalletType}
   * @memberof ResponseSellOrder
   */
  makerWalletType: WalletType;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  takerWalletId: string;
  /**
   *
   * @type {WalletType}
   * @memberof ResponseSellOrder
   */
  takerWalletType: WalletType;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  makeTokenDataId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  takeTokenDataId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  companyId: string;
  /**
   *
   * @type {number}
   * @memberof ResponseSellOrder
   */
  makeAmount: number;
  /**
   *
   * @type {number}
   * @memberof ResponseSellOrder
   */
  takeAmount: number;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  status: string;
  /**
   *
   * @type {MarketPlaceOrderTypesEnum}
   * @memberof ResponseSellOrder
   */
  type: MarketPlaceOrderTypesEnum;
  /**
   *
   * @type {boolean}
   * @memberof ResponseSellOrder
   */
  isClaimed: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  exchangeContract: string;
  /**
   *
   * @type {number}
   * @memberof ResponseSellOrder
   */
  startTime: number;
  /**
   *
   * @type {number}
   * @memberof ResponseSellOrder
   */
  endTime: number;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  signature: string;
  /**
   *
   * @type {string}
   * @memberof ResponseSellOrder
   */
  id: string;
}
/**
 *
 * @export
 * @interface ResponseTokenData
 */
export interface ResponseTokenData {
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  tokenGroupId?: string;
  /**
   *
   * @type {TokenDataType}
   * @memberof ResponseTokenData
   */
  type: TokenDataType;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  creatorId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  externalUri: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  imageUri: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  videoUri: string;
  /**
   *
   * @type {number}
   * @memberof ResponseTokenData
   */
  supply: number;
  /**
   *
   * @type {ModelObject}
   * @memberof ResponseTokenData
   */
  attributes: ModelObject;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  externalMetadataUri: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  reserveTokenDataId: string;
  /**
   *
   * @type {number}
   * @memberof ResponseTokenData
   */
  reserveTokenDataAmount: number;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  assetContractId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  tokenId: string;
  /**
   *
   * @type {ModelObject}
   * @memberof ResponseTokenData
   */
  lazyForm: ModelObject;
  /**
   *
   * @type {ModelObject}
   * @memberof ResponseTokenData
   */
  encodedFormBytes: ModelObject;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  minterWalletId: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  minterPublicKey: string;
  /**
   *
   * @type {string}
   * @memberof ResponseTokenData
   */
  id: string;
}
/**
 *
 * @export
 * @interface ResponsesAnyArray_
 */
export interface ResponsesAnyArray_ {
  /**
   *
   * @type {Array<ModelObject>}
   * @memberof ResponsesAnyArray_
   */
  data: Array<ModelObject>;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesAnyArray_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesAnyArray_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesBoolean_
 */
export interface ResponsesBoolean_ {
  /**
   *
   * @type {boolean}
   * @memberof ResponsesBoolean_
   */
  data: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesBoolean_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesBoolean_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesCryptoWalletArray_
 */
export interface ResponsesCryptoWalletArray_ {
  /**
   *
   * @type {Array<CryptoWallet>}
   * @memberof ResponsesCryptoWalletArray_
   */
  data: Array<CryptoWallet>;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesCryptoWalletArray_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesCryptoWalletArray_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesCryptoWallet_
 */
export interface ResponsesCryptoWallet_ {
  /**
   *
   * @type {CryptoWallet}
   * @memberof ResponsesCryptoWallet_
   */
  data: CryptoWallet;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesCryptoWallet_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesCryptoWallet_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesICreateTokenTransferResp_
 */
export interface ResponsesICreateTokenTransferResp_ {
  /**
   *
   * @type {ICreateTokenTransferResp}
   * @memberof ResponsesICreateTokenTransferResp_
   */
  data: ICreateTokenTransferResp;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesICreateTokenTransferResp_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesICreateTokenTransferResp_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIGetTokenGroupDataResp_
 */
export interface ResponsesIGetTokenGroupDataResp_ {
  /**
   *
   * @type {IGetTokenGroupDataResp}
   * @memberof ResponsesIGetTokenGroupDataResp_
   */
  data: IGetTokenGroupDataResp;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIGetTokenGroupDataResp_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIGetTokenGroupDataResp_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIGetWalletResp_
 */
export interface ResponsesIGetWalletResp_ {
  /**
   *
   * @type {IGetWalletResp}
   * @memberof ResponsesIGetWalletResp_
   */
  data: IGetWalletResp;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIGetWalletResp_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIGetWalletResp_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIListBuyOrdersDataResp_
 */
export interface ResponsesIListBuyOrdersDataResp_ {
  /**
   *
   * @type {IListBuyOrdersDataResp}
   * @memberof ResponsesIListBuyOrdersDataResp_
   */
  data: IListBuyOrdersDataResp;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIListBuyOrdersDataResp_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIListBuyOrdersDataResp_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIListSellOrdersDataResp_
 */
export interface ResponsesIListSellOrdersDataResp_ {
  /**
   *
   * @type {IListSellOrdersDataResp}
   * @memberof ResponsesIListSellOrdersDataResp_
   */
  data: IListSellOrdersDataResp;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIListSellOrdersDataResp_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIListSellOrdersDataResp_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIListTokenGroupDataResp_
 */
export interface ResponsesIListTokenGroupDataResp_ {
  /**
   *
   * @type {IListTokenGroupDataResp}
   * @memberof ResponsesIListTokenGroupDataResp_
   */
  data: IListTokenGroupDataResp;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIListTokenGroupDataResp_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIListTokenGroupDataResp_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIRefreshTokenResponse_
 */
export interface ResponsesIRefreshTokenResponse_ {
  /**
   *
   * @type {IRefreshTokenResponse}
   * @memberof ResponsesIRefreshTokenResponse_
   */
  data: IRefreshTokenResponse;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIRefreshTokenResponse_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIRefreshTokenResponse_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesISignMarketplaceOrderString_
 */
export interface ResponsesISignMarketplaceOrderString_ {
  /**
   *
   * @type {ISignMarketplaceOrderString}
   * @memberof ResponsesISignMarketplaceOrderString_
   */
  data: ISignMarketplaceOrderString;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesISignMarketplaceOrderString_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesISignMarketplaceOrderString_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesISubmitBuyOrderResponse_
 */
export interface ResponsesISubmitBuyOrderResponse_ {
  /**
   *
   * @type {ISubmitBuyOrderResponse}
   * @memberof ResponsesISubmitBuyOrderResponse_
   */
  data: ISubmitBuyOrderResponse;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesISubmitBuyOrderResponse_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesISubmitBuyOrderResponse_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesISubmitTokenTransferResp_
 */
export interface ResponsesISubmitTokenTransferResp_ {
  /**
   *
   * @type {ISubmitTokenTransferResp}
   * @memberof ResponsesISubmitTokenTransferResp_
   */
  data: ISubmitTokenTransferResp;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesISubmitTokenTransferResp_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesISubmitTokenTransferResp_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIWalletAuthResponse_
 */
export interface ResponsesIWalletAuthResponse_ {
  /**
   *
   * @type {IWalletAuthResponse}
   * @memberof ResponsesIWalletAuthResponse_
   */
  data: IWalletAuthResponse;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIWalletAuthResponse_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIWalletAuthResponse_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesIWalletLoginResponse_
 */
export interface ResponsesIWalletLoginResponse_ {
  /**
   *
   * @type {IWalletLoginResponse}
   * @memberof ResponsesIWalletLoginResponse_
   */
  data: IWalletLoginResponse;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesIWalletLoginResponse_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesIWalletLoginResponse_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseCompany_
 */
export interface ResponsesResponseCompany_ {
  /**
   *
   * @type {ResponseCompany}
   * @memberof ResponsesResponseCompany_
   */
  data: ResponseCompany;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseCompany_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseCompany_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseContract_
 */
export interface ResponsesResponseContract_ {
  /**
   *
   * @type {ResponseContract}
   * @memberof ResponsesResponseContract_
   */
  data: ResponseContract;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseContract_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseContract_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseCryptoWalletArray_
 */
export interface ResponsesResponseCryptoWalletArray_ {
  /**
   *
   * @type {Array<ResponseCryptoWallet>}
   * @memberof ResponsesResponseCryptoWalletArray_
   */
  data: Array<ResponseCryptoWallet>;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseCryptoWalletArray_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseCryptoWalletArray_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseCryptoWallet_
 */
export interface ResponsesResponseCryptoWallet_ {
  /**
   *
   * @type {ResponseCryptoWallet}
   * @memberof ResponsesResponseCryptoWallet_
   */
  data: ResponseCryptoWallet;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseCryptoWallet_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseCryptoWallet_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseIGetWallet_
 */
export interface ResponsesResponseIGetWallet_ {
  /**
   *
   * @type {ResponseIGetWallet}
   * @memberof ResponsesResponseIGetWallet_
   */
  data: ResponseIGetWallet;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseIGetWallet_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseIGetWallet_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseIListContracts_
 */
export interface ResponsesResponseIListContracts_ {
  /**
   *
   * @type {ResponseIListContracts}
   * @memberof ResponsesResponseIListContracts_
   */
  data: ResponseIListContracts;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseIListContracts_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseIListContracts_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseIListTokenData_
 */
export interface ResponsesResponseIListTokenData_ {
  /**
   *
   * @type {ResponseIListTokenData}
   * @memberof ResponsesResponseIListTokenData_
   */
  data: ResponseIListTokenData;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseIListTokenData_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseIListTokenData_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseIListUsersTokens_
 */
export interface ResponsesResponseIListUsersTokens_ {
  /**
   *
   * @type {ResponseIListUsersTokens}
   * @memberof ResponsesResponseIListUsersTokens_
   */
  data: ResponseIListUsersTokens;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseIListUsersTokens_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseIListUsersTokens_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseITokenData_
 */
export interface ResponsesResponseITokenData_ {
  /**
   *
   * @type {ResponseITokenData}
   * @memberof ResponsesResponseITokenData_
   */
  data: ResponseITokenData;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseITokenData_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseITokenData_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseNFTMintSaleArray_
 */
export interface ResponsesResponseNFTMintSaleArray_ {
  /**
   *
   * @type {Array<ResponseNFTMintSale>}
   * @memberof ResponsesResponseNFTMintSaleArray_
   */
  data: Array<ResponseNFTMintSale>;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseNFTMintSaleArray_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseNFTMintSaleArray_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesResponseTokenData_
 */
export interface ResponsesResponseTokenData_ {
  /**
   *
   * @type {ResponseTokenData}
   * @memberof ResponsesResponseTokenData_
   */
  data: ResponseTokenData;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesResponseTokenData_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesResponseTokenData_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesString_
 */
export interface ResponsesString_ {
  /**
   *
   * @type {string}
   * @memberof ResponsesString_
   */
  data: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesString_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesString_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesTokenGroupData_
 */
export interface ResponsesTokenGroupData_ {
  /**
   *
   * @type {TokenGroupData}
   * @memberof ResponsesTokenGroupData_
   */
  data: TokenGroupData;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesTokenGroupData_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesTokenGroupData_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesWalletBalanceArray_
 */
export interface ResponsesWalletBalanceArray_ {
  /**
   *
   * @type {Array<WalletBalance>}
   * @memberof ResponsesWalletBalanceArray_
   */
  data: Array<WalletBalance>;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesWalletBalanceArray_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesWalletBalanceArray_
   */
  message: string;
}
/**
 *
 * @export
 * @interface ResponsesWalletBalance_
 */
export interface ResponsesWalletBalance_ {
  /**
   *
   * @type {WalletBalance}
   * @memberof ResponsesWalletBalance_
   */
  data: WalletBalance;
  /**
   *
   * @type {boolean}
   * @memberof ResponsesWalletBalance_
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponsesWalletBalance_
   */
  message: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum TokenDataType {
  ETH = <any>'ETH',
  ERC20 = <any>'ERC20',
  ERC721 = <any>'ERC721',
  ERC721LAZY = <any>'ERC721_LAZY',
  ERC1155 = <any>'ERC1155',
  ERC1155LAZY = <any>'ERC1155_LAZY',
}
/**
 *
 * @export
 */
export type TokenGroupData = ModelObject;
/**
 *
 * @export
 * @interface WalletBalance
 */
export interface WalletBalance {
  /**
   *
   * @type {string}
   * @memberof WalletBalance
   */
  balance: string;
  /**
   *
   * @type {number}
   * @memberof WalletBalance
   */
  decimals: number;
  /**
   *
   * @type {string}
   * @memberof WalletBalance
   */
  symbol: string;
  /**
   *
   * @type {string}
   * @memberof WalletBalance
   */
  rawBalance: string;
  /**
   *
   * @type {string}
   * @memberof WalletBalance
   */
  chain?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum WalletRegistrationStatus {
  VERIFIED = <any>'VERIFIED',
  NOTVERIFIED = <any>'NOT_VERIFIED',
  NONE = <any>'NONE',
}
/**
 *
 * @export
 * @enum {string}
 */
export enum WalletType {
  NONCUSTODIAL = <any>'NONCUSTODIAL',
  CUSTODIAL = <any>'CUSTODIAL',
}
/**
 * AdminAPIsApi - fetch parameter creator
 * @export
 */
export const AdminAPIsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * It returns the company information.
     * @param {string} xApiKey - string - This is the company secret key that you got from the admin panel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompany(xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError('xApiKey', 'Required parameter xApiKey was null or undefined when calling getCompany.');
      }
      const localVarPath = `/admin/info`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get wallet balance for relayer being used for your company. Your company poc address is linked with your relayer.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelayerBalance(xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getRelayerBalance.',
        );
      }
      const localVarPath = `/admin/relayer-balance`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a company login to use the APIs
     * @param {ICreateCompany} body This it the company creation request data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCompany(body: ICreateCompany, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling postCompany.');
      }
      const localVarPath = `/admin/setup`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ICreateCompany' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AdminAPIsApi - functional programming interface
 * @export
 */
export const AdminAPIsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * It returns the company information.
     * @param {string} xApiKey - string - This is the company secret key that you got from the admin panel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompany(
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseCompany_> {
      const localVarFetchArgs = AdminAPIsApiFetchParamCreator(configuration).getCompany(xApiKey, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get wallet balance for relayer being used for your company. Your company poc address is linked with your relayer.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelayerBalance(
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesWalletBalance_> {
      const localVarFetchArgs = AdminAPIsApiFetchParamCreator(configuration).getRelayerBalance(xApiKey, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a company login to use the APIs
     * @param {ICreateCompany} body This it the company creation request data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCompany(
      body: ICreateCompany,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseCompany_> {
      const localVarFetchArgs = AdminAPIsApiFetchParamCreator(configuration).postCompany(body, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AdminAPIsApi - factory interface
 * @export
 */
export const AdminAPIsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * It returns the company information.
     * @param {string} xApiKey - string - This is the company secret key that you got from the admin panel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompany(xApiKey: string, options?: any) {
      return AdminAPIsApiFp(configuration).getCompany(xApiKey, options)(fetch, basePath);
    },
    /**
     * Get wallet balance for relayer being used for your company. Your company poc address is linked with your relayer.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelayerBalance(xApiKey: string, options?: any) {
      return AdminAPIsApiFp(configuration).getRelayerBalance(xApiKey, options)(fetch, basePath);
    },
    /**
     * Create a company login to use the APIs
     * @param {ICreateCompany} body This it the company creation request data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCompany(body: ICreateCompany, options?: any) {
      return AdminAPIsApiFp(configuration).postCompany(body, options)(fetch, basePath);
    },
  };
};

/**
 * AdminAPIsApi - object-oriented interface
 * @export
 * @class AdminAPIsApi
 * @extends {BaseAPI}
 */
export class AdminAPIsApi extends BaseAPI {
  /**
   * It returns the company information.
   * @param {string} xApiKey - string - This is the company secret key that you got from the admin panel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminAPIsApi
   */
  public getCompany(xApiKey: string, options?: any) {
    return AdminAPIsApiFp(this.configuration).getCompany(xApiKey, options)(this.fetch, this.basePath);
  }

  /**
   * Get wallet balance for relayer being used for your company. Your company poc address is linked with your relayer.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminAPIsApi
   */
  public getRelayerBalance(xApiKey: string, options?: any) {
    return AdminAPIsApiFp(this.configuration).getRelayerBalance(xApiKey, options)(this.fetch, this.basePath);
  }

  /**
   * Create a company login to use the APIs
   * @param {ICreateCompany} body This it the company creation request data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminAPIsApi
   */
  public postCompany(body: ICreateCompany, options?: any) {
    return AdminAPIsApiFp(this.configuration).postCompany(body, options)(this.fetch, this.basePath);
  }
}
/**
 * AirdropAPIsApi - fetch parameter creator
 * @export
 */
export const AirdropAPIsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you created in the previous step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTestFungibleTokenData(body: IMintData, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling mintTestFungibleTokenData.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling mintTestFungibleTokenData.',
        );
      }
      const localVarPath = `/airdrop/test-fungible-token-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IMintData' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokenData(body: IMintData, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling mintTokenData.');
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling mintTokenData.',
        );
      }
      const localVarPath = `/airdrop/token-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IMintData' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Mints an **amount** quantity of a particular token using the token group data id. The supply will be set to 1 for each token minted using this group. You can mint to multiple wallets at once. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintTokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokenGroupData(body: IMintTokenGroupData, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling mintTokenGroupData.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling mintTokenGroupData.',
        );
      }
      const localVarPath = `/airdrop/token-group-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IMintTokenGroupData' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AirdropAPIsApi - functional programming interface
 * @export
 */
export const AirdropAPIsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you created in the previous step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTestFungibleTokenData(
      body: IMintData,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesAnyArray_> {
      const localVarFetchArgs = AirdropAPIsApiFetchParamCreator(configuration).mintTestFungibleTokenData(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokenData(
      body: IMintData,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseNFTMintSaleArray_> {
      const localVarFetchArgs = AirdropAPIsApiFetchParamCreator(configuration).mintTokenData(body, xApiKey, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Mints an **amount** quantity of a particular token using the token group data id. The supply will be set to 1 for each token minted using this group. You can mint to multiple wallets at once. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintTokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokenGroupData(
      body: IMintTokenGroupData,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseNFTMintSaleArray_> {
      const localVarFetchArgs = AirdropAPIsApiFetchParamCreator(configuration).mintTokenGroupData(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AirdropAPIsApi - factory interface
 * @export
 */
export const AirdropAPIsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you created in the previous step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTestFungibleTokenData(body: IMintData, xApiKey: string, options?: any) {
      return AirdropAPIsApiFp(configuration).mintTestFungibleTokenData(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokenData(body: IMintData, xApiKey: string, options?: any) {
      return AirdropAPIsApiFp(configuration).mintTokenData(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Mints an **amount** quantity of a particular token using the token group data id. The supply will be set to 1 for each token minted using this group. You can mint to multiple wallets at once. Try fewer wallets if it doesn't work. Warning - This step costs gas.
     * @param {IMintTokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mintTokenGroupData(body: IMintTokenGroupData, xApiKey: string, options?: any) {
      return AirdropAPIsApiFp(configuration).mintTokenGroupData(body, xApiKey, options)(fetch, basePath);
    },
  };
};

/**
 * AirdropAPIsApi - object-oriented interface
 * @export
 * @class AirdropAPIsApi
 * @extends {BaseAPI}
 */
export class AirdropAPIsApi extends BaseAPI {
  /**
   * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
   * @param {IMintData} body This is a token data creation request description.
   * @param {string} xApiKey - This is the API key that you created in the previous step.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AirdropAPIsApi
   */
  public mintTestFungibleTokenData(body: IMintData, xApiKey: string, options?: any) {
    return AirdropAPIsApiFp(this.configuration).mintTestFungibleTokenData(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Mints an **amount** quantity of a particular token using the token data id. You can mint to multiple wallets at once, limited by supply. Try fewer wallets if it doesn't work. Warning - This step costs gas.
   * @param {IMintData} body This is a token data creation request description.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AirdropAPIsApi
   */
  public mintTokenData(body: IMintData, xApiKey: string, options?: any) {
    return AirdropAPIsApiFp(this.configuration).mintTokenData(body, xApiKey, options)(this.fetch, this.basePath);
  }

  /**
   * Mints an **amount** quantity of a particular token using the token group data id. The supply will be set to 1 for each token minted using this group. You can mint to multiple wallets at once. Try fewer wallets if it doesn't work. Warning - This step costs gas.
   * @param {IMintTokenGroupData} body This is a token data creation request description.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AirdropAPIsApi
   */
  public mintTokenGroupData(body: IMintTokenGroupData, xApiKey: string, options?: any) {
    return AirdropAPIsApiFp(this.configuration).mintTokenGroupData(body, xApiKey, options)(this.fetch, this.basePath);
  }
}
/**
 * ContractApisApi - fetch parameter creator
 * @export
 */
export const ContractApisApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new contract. You can treat this as a collection of items. Eg. T-shirts
     * @param {IContract} body - IContract - This is the request body that is sent to the API.
     * @param {string} xApiKey - This is the API secret key that is passed in the header of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract(body: IContract, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling createContract.');
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling createContract.',
        );
      }
      const localVarPath = `/contract/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IContract' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of contracts for company
     * @param {string} xApiKey - This is the API key that is passed in the header of the request.
     * @param {string} [lastId] - The last id of the last contract in the list. This is used to get the next set of contracts.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts(xApiKey: string, lastId?: string, size?: number, options: any = {}): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listContracts.',
        );
      }
      const localVarPath = `/contract/list`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContractApisApi - functional programming interface
 * @export
 */
export const ContractApisApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a new contract. You can treat this as a collection of items. Eg. T-shirts
     * @param {IContract} body - IContract - This is the request body that is sent to the API.
     * @param {string} xApiKey - This is the API secret key that is passed in the header of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract(
      body: IContract,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseContract_> {
      const localVarFetchArgs = ContractApisApiFetchParamCreator(configuration).createContract(body, xApiKey, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get list of contracts for company
     * @param {string} xApiKey - This is the API key that is passed in the header of the request.
     * @param {string} [lastId] - The last id of the last contract in the list. This is used to get the next set of contracts.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts(
      xApiKey: string,
      lastId?: string,
      size?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseIListContracts_> {
      const localVarFetchArgs = ContractApisApiFetchParamCreator(configuration).listContracts(
        xApiKey,
        lastId,
        size,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ContractApisApi - factory interface
 * @export
 */
export const ContractApisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Create a new contract. You can treat this as a collection of items. Eg. T-shirts
     * @param {IContract} body - IContract - This is the request body that is sent to the API.
     * @param {string} xApiKey - This is the API secret key that is passed in the header of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContract(body: IContract, xApiKey: string, options?: any) {
      return ContractApisApiFp(configuration).createContract(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Get list of contracts for company
     * @param {string} xApiKey - This is the API key that is passed in the header of the request.
     * @param {string} [lastId] - The last id of the last contract in the list. This is used to get the next set of contracts.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContracts(xApiKey: string, lastId?: string, size?: number, options?: any) {
      return ContractApisApiFp(configuration).listContracts(xApiKey, lastId, size, options)(fetch, basePath);
    },
  };
};

/**
 * ContractApisApi - object-oriented interface
 * @export
 * @class ContractApisApi
 * @extends {BaseAPI}
 */
export class ContractApisApi extends BaseAPI {
  /**
   * Create a new contract. You can treat this as a collection of items. Eg. T-shirts
   * @param {IContract} body - IContract - This is the request body that is sent to the API.
   * @param {string} xApiKey - This is the API secret key that is passed in the header of the request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApisApi
   */
  public createContract(body: IContract, xApiKey: string, options?: any) {
    return ContractApisApiFp(this.configuration).createContract(body, xApiKey, options)(this.fetch, this.basePath);
  }

  /**
   * Get list of contracts for company
   * @param {string} xApiKey - This is the API key that is passed in the header of the request.
   * @param {string} [lastId] - The last id of the last contract in the list. This is used to get the next set of contracts.
   * @param {number} [size] - number &#x3D; 50,
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApisApi
   */
  public listContracts(xApiKey: string, lastId?: string, size?: number, options?: any) {
    return ContractApisApiFp(this.configuration).listContracts(
      xApiKey,
      lastId,
      size,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * CustodianWalletAPIsDeprApi - fetch parameter creator
 * @export
 */
export const CustodianWalletAPIsDeprApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new wallet
     * @param {IWallet} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustodialWallet(body: IWallet, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCustodialWallet.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling createCustodialWallet.',
        );
      }
      const localVarPath = `/custodian-wallet/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWallet' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get wallet info
     * @param {string} walletId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustodialWallet(walletId: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling getCustodialWallet.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getCustodialWallet.',
        );
      }
      const localVarPath = `/custodian-wallet/info`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get wallet balance for wallet
     * @param {string} walletId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustodialWalletBalance(walletId: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling getCustodialWalletBalance.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getCustodialWalletBalance.',
        );
      }
      const localVarPath = `/custodian-wallet/balance`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of wallets of user
     * @param {string} email
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCustodialWallets(email: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'email' is not null or undefined
      if (email === null || email === undefined) {
        throw new RequiredError(
          'email',
          'Required parameter email was null or undefined when calling getUserCustodialWallets.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getUserCustodialWallets.',
        );
      }
      const localVarPath = `/custodian-wallet/email`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of wallets for company
     * @param {string} xApiKey
     * @param {string} [lastId]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCustodialWallets(xApiKey: string, lastId?: string, size?: number, options: any = {}): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listCustodialWallets.',
        );
      }
      const localVarPath = `/custodian-wallet/list`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sign a message by a wallet
     * @param {IWalletSign} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signMessage(body: IWalletSign, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling signMessage.');
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling signMessage.',
        );
      }
      const localVarPath = `/custodian-wallet/sign`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletSign' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sign a message by a wallet
     * @param {IWalletTypedSign} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTypedData(body: IWalletTypedSign, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling signTypedData.');
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling signTypedData.',
        );
      }
      const localVarPath = `/custodian-wallet/sign-typed-data`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletTypedSign' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustodianWalletAPIsDeprApi - functional programming interface
 * @export
 */
export const CustodianWalletAPIsDeprApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a new wallet
     * @param {IWallet} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustodialWallet(
      body: IWallet,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesCryptoWallet_> {
      const localVarFetchArgs = CustodianWalletAPIsDeprApiFetchParamCreator(configuration).createCustodialWallet(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get wallet info
     * @param {string} walletId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustodialWallet(
      walletId: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesCryptoWallet_> {
      const localVarFetchArgs = CustodianWalletAPIsDeprApiFetchParamCreator(configuration).getCustodialWallet(
        walletId,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get wallet balance for wallet
     * @param {string} walletId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustodialWalletBalance(
      walletId: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesWalletBalance_> {
      const localVarFetchArgs = CustodianWalletAPIsDeprApiFetchParamCreator(configuration).getCustodialWalletBalance(
        walletId,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get list of wallets of user
     * @param {string} email
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCustodialWallets(
      email: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesCryptoWalletArray_> {
      const localVarFetchArgs = CustodianWalletAPIsDeprApiFetchParamCreator(configuration).getUserCustodialWallets(
        email,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get list of wallets for company
     * @param {string} xApiKey
     * @param {string} [lastId]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCustodialWallets(
      xApiKey: string,
      lastId?: string,
      size?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIGetWalletResp_> {
      const localVarFetchArgs = CustodianWalletAPIsDeprApiFetchParamCreator(configuration).listCustodialWallets(
        xApiKey,
        lastId,
        size,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Sign a message by a wallet
     * @param {IWalletSign} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signMessage(
      body: IWalletSign,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesString_> {
      const localVarFetchArgs = CustodianWalletAPIsDeprApiFetchParamCreator(configuration).signMessage(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Sign a message by a wallet
     * @param {IWalletTypedSign} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTypedData(
      body: IWalletTypedSign,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesString_> {
      const localVarFetchArgs = CustodianWalletAPIsDeprApiFetchParamCreator(configuration).signTypedData(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CustodianWalletAPIsDeprApi - factory interface
 * @export
 */
export const CustodianWalletAPIsDeprApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a new wallet
     * @param {IWallet} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCustodialWallet(body: IWallet, xApiKey: string, options?: any) {
      return CustodianWalletAPIsDeprApiFp(configuration).createCustodialWallet(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Get wallet info
     * @param {string} walletId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustodialWallet(walletId: string, xApiKey: string, options?: any) {
      return CustodianWalletAPIsDeprApiFp(configuration).getCustodialWallet(
        walletId,
        xApiKey,
        options,
      )(fetch, basePath);
    },
    /**
     * Get wallet balance for wallet
     * @param {string} walletId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustodialWalletBalance(walletId: string, xApiKey: string, options?: any) {
      return CustodianWalletAPIsDeprApiFp(configuration).getCustodialWalletBalance(
        walletId,
        xApiKey,
        options,
      )(fetch, basePath);
    },
    /**
     * Get list of wallets of user
     * @param {string} email
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserCustodialWallets(email: string, xApiKey: string, options?: any) {
      return CustodianWalletAPIsDeprApiFp(configuration).getUserCustodialWallets(
        email,
        xApiKey,
        options,
      )(fetch, basePath);
    },
    /**
     * Get list of wallets for company
     * @param {string} xApiKey
     * @param {string} [lastId]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCustodialWallets(xApiKey: string, lastId?: string, size?: number, options?: any) {
      return CustodianWalletAPIsDeprApiFp(configuration).listCustodialWallets(
        xApiKey,
        lastId,
        size,
        options,
      )(fetch, basePath);
    },
    /**
     * Sign a message by a wallet
     * @param {IWalletSign} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signMessage(body: IWalletSign, xApiKey: string, options?: any) {
      return CustodianWalletAPIsDeprApiFp(configuration).signMessage(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Sign a message by a wallet
     * @param {IWalletTypedSign} body This is a wallet creation request description
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTypedData(body: IWalletTypedSign, xApiKey: string, options?: any) {
      return CustodianWalletAPIsDeprApiFp(configuration).signTypedData(body, xApiKey, options)(fetch, basePath);
    },
  };
};

/**
 * CustodianWalletAPIsDeprApi - object-oriented interface
 * @export
 * @class CustodianWalletAPIsDeprApi
 * @extends {BaseAPI}
 */
export class CustodianWalletAPIsDeprApi extends BaseAPI {
  /**
   * Create a new wallet
   * @param {IWallet} body This is a wallet creation request description
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustodianWalletAPIsDeprApi
   */
  public createCustodialWallet(body: IWallet, xApiKey: string, options?: any) {
    return CustodianWalletAPIsDeprApiFp(this.configuration).createCustodialWallet(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get wallet info
   * @param {string} walletId
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustodianWalletAPIsDeprApi
   */
  public getCustodialWallet(walletId: string, xApiKey: string, options?: any) {
    return CustodianWalletAPIsDeprApiFp(this.configuration).getCustodialWallet(
      walletId,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get wallet balance for wallet
   * @param {string} walletId
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustodianWalletAPIsDeprApi
   */
  public getCustodialWalletBalance(walletId: string, xApiKey: string, options?: any) {
    return CustodianWalletAPIsDeprApiFp(this.configuration).getCustodialWalletBalance(
      walletId,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get list of wallets of user
   * @param {string} email
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustodianWalletAPIsDeprApi
   */
  public getUserCustodialWallets(email: string, xApiKey: string, options?: any) {
    return CustodianWalletAPIsDeprApiFp(this.configuration).getUserCustodialWallets(
      email,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get list of wallets for company
   * @param {string} xApiKey
   * @param {string} [lastId]
   * @param {number} [size]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustodianWalletAPIsDeprApi
   */
  public listCustodialWallets(xApiKey: string, lastId?: string, size?: number, options?: any) {
    return CustodianWalletAPIsDeprApiFp(this.configuration).listCustodialWallets(
      xApiKey,
      lastId,
      size,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Sign a message by a wallet
   * @param {IWalletSign} body This is a wallet creation request description
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustodianWalletAPIsDeprApi
   */
  public signMessage(body: IWalletSign, xApiKey: string, options?: any) {
    return CustodianWalletAPIsDeprApiFp(this.configuration).signMessage(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Sign a message by a wallet
   * @param {IWalletTypedSign} body This is a wallet creation request description
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustodianWalletAPIsDeprApi
   */
  public signTypedData(body: IWalletTypedSign, xApiKey: string, options?: any) {
    return CustodianWalletAPIsDeprApiFp(this.configuration).signTypedData(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * EmailAuthApi - fetch parameter creator
 * @export
 */
export const EmailAuthApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Send email verification link
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailVerificationLink(body: IWalletCustomAuth, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling emailVerificationLink.',
        );
      }
      const localVarPath = `/custom-auth/email-verification-link`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletCustomAuth' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    jwks(options: any = {}): FetchArgs {
      const localVarPath = `/custom-auth/jwks`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Login user with email/password
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(body: IWalletCustomAuth, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling loginUser.');
      }
      const localVarPath = `/custom-auth/login-user`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletCustomAuth' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Register user with email/password
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(body: IWalletCustomAuth, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling registerUser.');
      }
      const localVarPath = `/custom-auth/register-user`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletCustomAuth' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verify email with link
     * @param {IWalletResetPassword} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(body: IWalletResetPassword, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling resetPassword.');
      }
      const localVarPath = `/custom-auth/password-reset`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletResetPassword' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send password reset link
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPasswordLink(body: IWalletCustomAuth, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling resetPasswordLink.',
        );
      }
      const localVarPath = `/custom-auth/reset-password-link`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletCustomAuth' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verify email with link
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail(token?: string, options: any = {}): FetchArgs {
      const localVarPath = `/custom-auth/verify-email`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined) {
        localVarQueryParameter['token'] = token;
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EmailAuthApi - functional programming interface
 * @export
 */
export const EmailAuthApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Send email verification link
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailVerificationLink(
      body: IWalletCustomAuth,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesString_> {
      const localVarFetchArgs = EmailAuthApiFetchParamCreator(configuration).emailVerificationLink(body, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Return jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    jwks(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesString_> {
      const localVarFetchArgs = EmailAuthApiFetchParamCreator(configuration).jwks(options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Login user with email/password
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      body: IWalletCustomAuth,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIWalletLoginResponse_> {
      const localVarFetchArgs = EmailAuthApiFetchParamCreator(configuration).loginUser(body, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Register user with email/password
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      body: IWalletCustomAuth,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesCryptoWallet_> {
      const localVarFetchArgs = EmailAuthApiFetchParamCreator(configuration).registerUser(body, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Verify email with link
     * @param {IWalletResetPassword} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(
      body: IWalletResetPassword,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesCryptoWallet_> {
      const localVarFetchArgs = EmailAuthApiFetchParamCreator(configuration).resetPassword(body, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Send password reset link
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPasswordLink(
      body: IWalletCustomAuth,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesString_> {
      const localVarFetchArgs = EmailAuthApiFetchParamCreator(configuration).resetPasswordLink(body, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Verify email with link
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail(
      token?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesCryptoWallet_> {
      const localVarFetchArgs = EmailAuthApiFetchParamCreator(configuration).verifyEmail(token, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * EmailAuthApi - factory interface
 * @export
 */
export const EmailAuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Send email verification link
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailVerificationLink(body: IWalletCustomAuth, options?: any) {
      return EmailAuthApiFp(configuration).emailVerificationLink(body, options)(fetch, basePath);
    },
    /**
     * Return jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    jwks(options?: any) {
      return EmailAuthApiFp(configuration).jwks(options)(fetch, basePath);
    },
    /**
     * Login user with email/password
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(body: IWalletCustomAuth, options?: any) {
      return EmailAuthApiFp(configuration).loginUser(body, options)(fetch, basePath);
    },
    /**
     * Register user with email/password
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(body: IWalletCustomAuth, options?: any) {
      return EmailAuthApiFp(configuration).registerUser(body, options)(fetch, basePath);
    },
    /**
     * Verify email with link
     * @param {IWalletResetPassword} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(body: IWalletResetPassword, options?: any) {
      return EmailAuthApiFp(configuration).resetPassword(body, options)(fetch, basePath);
    },
    /**
     * Send password reset link
     * @param {IWalletCustomAuth} body This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPasswordLink(body: IWalletCustomAuth, options?: any) {
      return EmailAuthApiFp(configuration).resetPasswordLink(body, options)(fetch, basePath);
    },
    /**
     * Verify email with link
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail(token?: string, options?: any) {
      return EmailAuthApiFp(configuration).verifyEmail(token, options)(fetch, basePath);
    },
  };
};

/**
 * EmailAuthApi - object-oriented interface
 * @export
 * @class EmailAuthApi
 * @extends {BaseAPI}
 */
export class EmailAuthApi extends BaseAPI {
  /**
   * Send email verification link
   * @param {IWalletCustomAuth} body This is a wallet creation request description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailAuthApi
   */
  public emailVerificationLink(body: IWalletCustomAuth, options?: any) {
    return EmailAuthApiFp(this.configuration).emailVerificationLink(body, options)(this.fetch, this.basePath);
  }

  /**
   * Return jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailAuthApi
   */
  public jwks(options?: any) {
    return EmailAuthApiFp(this.configuration).jwks(options)(this.fetch, this.basePath);
  }

  /**
   * Login user with email/password
   * @param {IWalletCustomAuth} body This is a wallet creation request description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailAuthApi
   */
  public loginUser(body: IWalletCustomAuth, options?: any) {
    return EmailAuthApiFp(this.configuration).loginUser(body, options)(this.fetch, this.basePath);
  }

  /**
   * Register user with email/password
   * @param {IWalletCustomAuth} body This is a wallet creation request description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailAuthApi
   */
  public registerUser(body: IWalletCustomAuth, options?: any) {
    return EmailAuthApiFp(this.configuration).registerUser(body, options)(this.fetch, this.basePath);
  }

  /**
   * Verify email with link
   * @param {IWalletResetPassword} body This is a wallet creation request description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailAuthApi
   */
  public resetPassword(body: IWalletResetPassword, options?: any) {
    return EmailAuthApiFp(this.configuration).resetPassword(body, options)(this.fetch, this.basePath);
  }

  /**
   * Send password reset link
   * @param {IWalletCustomAuth} body This is a wallet creation request description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailAuthApi
   */
  public resetPasswordLink(body: IWalletCustomAuth, options?: any) {
    return EmailAuthApiFp(this.configuration).resetPasswordLink(body, options)(this.fetch, this.basePath);
  }

  /**
   * Verify email with link
   * @param {string} [token]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailAuthApi
   */
  public verifyEmail(token?: string, options?: any) {
    return EmailAuthApiFp(this.configuration).verifyEmail(token, options)(this.fetch, this.basePath);
  }
}
/**
 * MarketApisApi - fetch parameter creator
 * @export
 */
export const MarketApisApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
         * Create bid for a buy order
         * @param {ICreateBuyOrder} body - ICreateBuyOrder - This is the request body that is sent to the
API.
         * @param {string} accessToken - The access token of the user who is creating the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createBuyOrder(body: ICreateBuyOrder, accessToken: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling createBuyOrder.');
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling createBuyOrder.',
        );
      }
      const localVarPath = `/market/create-bid-order`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accessToken !== undefined && accessToken !== null) {
        localVarHeaderParameter['access-token'] = String(accessToken);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ICreateBuyOrder' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates sell order for minting new tokens. This API is to be called by the client's server for listing new tokens on sale.
     * @param {ICreateMintSellOrder} body This is a sell order creation request description
     * @param {string} xApiKey - This is the API key that is passed in the header of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMintSellOrder(body: ICreateMintSellOrder, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createMintSellOrder.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling createMintSellOrder.',
        );
      }
      const localVarPath = `/market/create-mint-sell-order`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ICreateMintSellOrder' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
         * Creates sell order and return form data to sign
         * @param {ICreateSellOrder} body - ICreateSellOrder - This is the request body that is sent to
the API.
         * @param {string} accessToken - The access token of the user who is creating the sell order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createSellOrder(body: ICreateSellOrder, accessToken: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling createSellOrder.');
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling createSellOrder.',
        );
      }
      const localVarPath = `/market/create-sell-order`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accessToken !== undefined && accessToken !== null) {
        localVarHeaderParameter['access-token'] = String(accessToken);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ICreateSellOrder' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * It returns a list of buy orders for a given company
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The last id of the last item in the previous page.
     * @param {number} [size] - The number of records to return.
     * @param {string} [walletId] - The walletId of the wallet that you want to list the buy orders for.
     * @param {string} [tokenDataId] - The id of the token data you want to list the buy orders for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBidOrders(
      xApiKey: string,
      lastId?: string,
      size?: number,
      walletId?: string,
      tokenDataId?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listBidOrders.',
        );
      }
      const localVarPath = `/market/list-bid-orders`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (tokenDataId !== undefined) {
        localVarQueryParameter['tokenDataId'] = tokenDataId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * It returns a list of sell orders for a company
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The last id of the last sell order returned. This is used to paginate the results.
     * @param {number} [size] - The number of sell orders to return.
     * @param {string} [walletId] - The walletId of the wallet that you want to list the sell orders for.
     * @param {string} [tokenDataId] - The id of the token data you want to list sell orders for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSellOrders(
      xApiKey: string,
      lastId?: string,
      size?: number,
      walletId?: string,
      tokenDataId?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listSellOrders.',
        );
      }
      const localVarPath = `/market/list-sell-orders`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (tokenDataId !== undefined) {
        localVarQueryParameter['tokenDataId'] = tokenDataId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
         * It takes a signed bid order, saves it to the database, and returns the transaction hash and the token that was bid on
         * @param {ISignatureResponse} body - ISignatureResponse - This is the request body that is sent
to the API. It is a JSON object that contains the id of the bid order and the signature of the bid
order.
         * @param {string} accessToken -  The access token of the user who is creating the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitBidOrder(body: ISignatureResponse, accessToken: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling submitBidOrder.');
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling submitBidOrder.',
        );
      }
      const localVarPath = `/market/submit-bid-order`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accessToken !== undefined && accessToken !== null) {
        localVarHeaderParameter['access-token'] = String(accessToken);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ISignatureResponse' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
         * This function is called by the client when the user has signed the sell order form. The function saves the signed form and returns a success message
         * @param {ISignatureResponse} body - ISignatureResponse - This is the body of the request. It&#x27;s a
JSON object that contains the id of the order and the signature.
         * @param {string} accessToken - This is the access token of user selling the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitSellOrder(body: ISignatureResponse, accessToken: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling submitSellOrder.');
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling submitSellOrder.',
        );
      }
      const localVarPath = `/market/submit-sell-order`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accessToken !== undefined && accessToken !== null) {
        localVarHeaderParameter['access-token'] = String(accessToken);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ISignatureResponse' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MarketApisApi - functional programming interface
 * @export
 */
export const MarketApisApiFp = function (configuration?: Configuration) {
  return {
    /**
         * Create bid for a buy order
         * @param {ICreateBuyOrder} body - ICreateBuyOrder - This is the request body that is sent to the
API.
         * @param {string} accessToken - The access token of the user who is creating the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createBuyOrder(
      body: ICreateBuyOrder,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesISignMarketplaceOrderString_> {
      const localVarFetchArgs = MarketApisApiFetchParamCreator(configuration).createBuyOrder(
        body,
        accessToken,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Creates sell order for minting new tokens. This API is to be called by the client's server for listing new tokens on sale.
     * @param {ICreateMintSellOrder} body This is a sell order creation request description
     * @param {string} xApiKey - This is the API key that is passed in the header of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMintSellOrder(
      body: ICreateMintSellOrder,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesISignMarketplaceOrderString_> {
      const localVarFetchArgs = MarketApisApiFetchParamCreator(configuration).createMintSellOrder(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
         * Creates sell order and return form data to sign
         * @param {ICreateSellOrder} body - ICreateSellOrder - This is the request body that is sent to
the API.
         * @param {string} accessToken - The access token of the user who is creating the sell order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createSellOrder(
      body: ICreateSellOrder,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesISignMarketplaceOrderString_> {
      const localVarFetchArgs = MarketApisApiFetchParamCreator(configuration).createSellOrder(
        body,
        accessToken,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * It returns a list of buy orders for a given company
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The last id of the last item in the previous page.
     * @param {number} [size] - The number of records to return.
     * @param {string} [walletId] - The walletId of the wallet that you want to list the buy orders for.
     * @param {string} [tokenDataId] - The id of the token data you want to list the buy orders for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBidOrders(
      xApiKey: string,
      lastId?: string,
      size?: number,
      walletId?: string,
      tokenDataId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIListBuyOrdersDataResp_> {
      const localVarFetchArgs = MarketApisApiFetchParamCreator(configuration).listBidOrders(
        xApiKey,
        lastId,
        size,
        walletId,
        tokenDataId,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * It returns a list of sell orders for a company
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The last id of the last sell order returned. This is used to paginate the results.
     * @param {number} [size] - The number of sell orders to return.
     * @param {string} [walletId] - The walletId of the wallet that you want to list the sell orders for.
     * @param {string} [tokenDataId] - The id of the token data you want to list sell orders for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSellOrders(
      xApiKey: string,
      lastId?: string,
      size?: number,
      walletId?: string,
      tokenDataId?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIListSellOrdersDataResp_> {
      const localVarFetchArgs = MarketApisApiFetchParamCreator(configuration).listSellOrders(
        xApiKey,
        lastId,
        size,
        walletId,
        tokenDataId,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
         * It takes a signed bid order, saves it to the database, and returns the transaction hash and the token that was bid on
         * @param {ISignatureResponse} body - ISignatureResponse - This is the request body that is sent
to the API. It is a JSON object that contains the id of the bid order and the signature of the bid
order.
         * @param {string} accessToken -  The access token of the user who is creating the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitBidOrder(
      body: ISignatureResponse,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesISubmitBuyOrderResponse_> {
      const localVarFetchArgs = MarketApisApiFetchParamCreator(configuration).submitBidOrder(
        body,
        accessToken,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
         * This function is called by the client when the user has signed the sell order form. The function saves the signed form and returns a success message
         * @param {ISignatureResponse} body - ISignatureResponse - This is the body of the request. It&#x27;s a
JSON object that contains the id of the order and the signature.
         * @param {string} accessToken - This is the access token of user selling the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitSellOrder(
      body: ISignatureResponse,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesString_> {
      const localVarFetchArgs = MarketApisApiFetchParamCreator(configuration).submitSellOrder(
        body,
        accessToken,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * MarketApisApi - factory interface
 * @export
 */
export const MarketApisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
         * Create bid for a buy order
         * @param {ICreateBuyOrder} body - ICreateBuyOrder - This is the request body that is sent to the
API.
         * @param {string} accessToken - The access token of the user who is creating the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createBuyOrder(body: ICreateBuyOrder, accessToken: string, options?: any) {
      return MarketApisApiFp(configuration).createBuyOrder(body, accessToken, options)(fetch, basePath);
    },
    /**
     * Creates sell order for minting new tokens. This API is to be called by the client's server for listing new tokens on sale.
     * @param {ICreateMintSellOrder} body This is a sell order creation request description
     * @param {string} xApiKey - This is the API key that is passed in the header of the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMintSellOrder(body: ICreateMintSellOrder, xApiKey: string, options?: any) {
      return MarketApisApiFp(configuration).createMintSellOrder(body, xApiKey, options)(fetch, basePath);
    },
    /**
         * Creates sell order and return form data to sign
         * @param {ICreateSellOrder} body - ICreateSellOrder - This is the request body that is sent to
the API.
         * @param {string} accessToken - The access token of the user who is creating the sell order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createSellOrder(body: ICreateSellOrder, accessToken: string, options?: any) {
      return MarketApisApiFp(configuration).createSellOrder(body, accessToken, options)(fetch, basePath);
    },
    /**
     * It returns a list of buy orders for a given company
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The last id of the last item in the previous page.
     * @param {number} [size] - The number of records to return.
     * @param {string} [walletId] - The walletId of the wallet that you want to list the buy orders for.
     * @param {string} [tokenDataId] - The id of the token data you want to list the buy orders for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBidOrders(
      xApiKey: string,
      lastId?: string,
      size?: number,
      walletId?: string,
      tokenDataId?: string,
      options?: any,
    ) {
      return MarketApisApiFp(configuration).listBidOrders(
        xApiKey,
        lastId,
        size,
        walletId,
        tokenDataId,
        options,
      )(fetch, basePath);
    },
    /**
     * It returns a list of sell orders for a company
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The last id of the last sell order returned. This is used to paginate the results.
     * @param {number} [size] - The number of sell orders to return.
     * @param {string} [walletId] - The walletId of the wallet that you want to list the sell orders for.
     * @param {string} [tokenDataId] - The id of the token data you want to list sell orders for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSellOrders(
      xApiKey: string,
      lastId?: string,
      size?: number,
      walletId?: string,
      tokenDataId?: string,
      options?: any,
    ) {
      return MarketApisApiFp(configuration).listSellOrders(
        xApiKey,
        lastId,
        size,
        walletId,
        tokenDataId,
        options,
      )(fetch, basePath);
    },
    /**
         * It takes a signed bid order, saves it to the database, and returns the transaction hash and the token that was bid on
         * @param {ISignatureResponse} body - ISignatureResponse - This is the request body that is sent
to the API. It is a JSON object that contains the id of the bid order and the signature of the bid
order.
         * @param {string} accessToken -  The access token of the user who is creating the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitBidOrder(body: ISignatureResponse, accessToken: string, options?: any) {
      return MarketApisApiFp(configuration).submitBidOrder(body, accessToken, options)(fetch, basePath);
    },
    /**
         * This function is called by the client when the user has signed the sell order form. The function saves the signed form and returns a success message
         * @param {ISignatureResponse} body - ISignatureResponse - This is the body of the request. It&#x27;s a
JSON object that contains the id of the order and the signature.
         * @param {string} accessToken - This is the access token of user selling the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitSellOrder(body: ISignatureResponse, accessToken: string, options?: any) {
      return MarketApisApiFp(configuration).submitSellOrder(body, accessToken, options)(fetch, basePath);
    },
  };
};

/**
 * MarketApisApi - object-oriented interface
 * @export
 * @class MarketApisApi
 * @extends {BaseAPI}
 */
export class MarketApisApi extends BaseAPI {
  /**
     * Create bid for a buy order
     * @param {ICreateBuyOrder} body - ICreateBuyOrder - This is the request body that is sent to the
API.
     * @param {string} accessToken - The access token of the user who is creating the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApisApi
     */
  public createBuyOrder(body: ICreateBuyOrder, accessToken: string, options?: any) {
    return MarketApisApiFp(this.configuration).createBuyOrder(body, accessToken, options)(this.fetch, this.basePath);
  }

  /**
   * Creates sell order for minting new tokens. This API is to be called by the client's server for listing new tokens on sale.
   * @param {ICreateMintSellOrder} body This is a sell order creation request description
   * @param {string} xApiKey - This is the API key that is passed in the header of the request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApisApi
   */
  public createMintSellOrder(body: ICreateMintSellOrder, xApiKey: string, options?: any) {
    return MarketApisApiFp(this.configuration).createMintSellOrder(body, xApiKey, options)(this.fetch, this.basePath);
  }

  /**
     * Creates sell order and return form data to sign
     * @param {ICreateSellOrder} body - ICreateSellOrder - This is the request body that is sent to
the API.
     * @param {string} accessToken - The access token of the user who is creating the sell order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApisApi
     */
  public createSellOrder(body: ICreateSellOrder, accessToken: string, options?: any) {
    return MarketApisApiFp(this.configuration).createSellOrder(body, accessToken, options)(this.fetch, this.basePath);
  }

  /**
   * It returns a list of buy orders for a given company
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {string} [lastId] - The last id of the last item in the previous page.
   * @param {number} [size] - The number of records to return.
   * @param {string} [walletId] - The walletId of the wallet that you want to list the buy orders for.
   * @param {string} [tokenDataId] - The id of the token data you want to list the buy orders for.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApisApi
   */
  public listBidOrders(
    xApiKey: string,
    lastId?: string,
    size?: number,
    walletId?: string,
    tokenDataId?: string,
    options?: any,
  ) {
    return MarketApisApiFp(this.configuration).listBidOrders(
      xApiKey,
      lastId,
      size,
      walletId,
      tokenDataId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * It returns a list of sell orders for a company
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {string} [lastId] - The last id of the last sell order returned. This is used to paginate the results.
   * @param {number} [size] - The number of sell orders to return.
   * @param {string} [walletId] - The walletId of the wallet that you want to list the sell orders for.
   * @param {string} [tokenDataId] - The id of the token data you want to list sell orders for.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketApisApi
   */
  public listSellOrders(
    xApiKey: string,
    lastId?: string,
    size?: number,
    walletId?: string,
    tokenDataId?: string,
    options?: any,
  ) {
    return MarketApisApiFp(this.configuration).listSellOrders(
      xApiKey,
      lastId,
      size,
      walletId,
      tokenDataId,
      options,
    )(this.fetch, this.basePath);
  }

  /**
     * It takes a signed bid order, saves it to the database, and returns the transaction hash and the token that was bid on
     * @param {ISignatureResponse} body - ISignatureResponse - This is the request body that is sent
to the API. It is a JSON object that contains the id of the bid order and the signature of the bid
order.
     * @param {string} accessToken -  The access token of the user who is creating the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApisApi
     */
  public submitBidOrder(body: ISignatureResponse, accessToken: string, options?: any) {
    return MarketApisApiFp(this.configuration).submitBidOrder(body, accessToken, options)(this.fetch, this.basePath);
  }

  /**
     * This function is called by the client when the user has signed the sell order form. The function saves the signed form and returns a success message
     * @param {ISignatureResponse} body - ISignatureResponse - This is the body of the request. It&#x27;s a
JSON object that contains the id of the order and the signature.
     * @param {string} accessToken - This is the access token of user selling the token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketApisApi
     */
  public submitSellOrder(body: ISignatureResponse, accessToken: string, options?: any) {
    return MarketApisApiFp(this.configuration).submitSellOrder(body, accessToken, options)(this.fetch, this.basePath);
  }
}
/**
 * NonCustodialWalletAPIsApi - fetch parameter creator
 * @export
 */
export const NonCustodialWalletAPIsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * It gets the wallets of a user.
     * @param {string} email - The email of the user you want to get the wallets for.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWallets(email: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'email' is not null or undefined
      if (email === null || email === undefined) {
        throw new RequiredError('email', 'Required parameter email was null or undefined when calling getUserWallets.');
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getUserWallets.',
        );
      }
      const localVarPath = `/wallet/email`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * It gets the wallet info.
     * @param {string} walletId - The wallet id of the wallet you want to get.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(walletId: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling getWallet.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError('xApiKey', 'Required parameter xApiKey was null or undefined when calling getWallet.');
      }
      const localVarPath = `/wallet/get`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * It returns a list of wallets for a company.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The lastId is the last wallet id that was returned in the previous request. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(xApiKey: string, lastId?: string, size?: number, options: any = {}): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listWallets.',
        );
      }
      const localVarPath = `/wallet/list`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NonCustodialWalletAPIsApi - functional programming interface
 * @export
 */
export const NonCustodialWalletAPIsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * It gets the wallets of a user.
     * @param {string} email - The email of the user you want to get the wallets for.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWallets(
      email: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseCryptoWalletArray_> {
      const localVarFetchArgs = NonCustodialWalletAPIsApiFetchParamCreator(configuration).getUserWallets(
        email,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * It gets the wallet info.
     * @param {string} walletId - The wallet id of the wallet you want to get.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(
      walletId: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseCryptoWallet_> {
      const localVarFetchArgs = NonCustodialWalletAPIsApiFetchParamCreator(configuration).getWallet(
        walletId,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * It returns a list of wallets for a company.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The lastId is the last wallet id that was returned in the previous request. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(
      xApiKey: string,
      lastId?: string,
      size?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseIGetWallet_> {
      const localVarFetchArgs = NonCustodialWalletAPIsApiFetchParamCreator(configuration).listWallets(
        xApiKey,
        lastId,
        size,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * NonCustodialWalletAPIsApi - factory interface
 * @export
 */
export const NonCustodialWalletAPIsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * It gets the wallets of a user.
     * @param {string} email - The email of the user you want to get the wallets for.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWallets(email: string, xApiKey: string, options?: any) {
      return NonCustodialWalletAPIsApiFp(configuration).getUserWallets(email, xApiKey, options)(fetch, basePath);
    },
    /**
     * It gets the wallet info.
     * @param {string} walletId - The wallet id of the wallet you want to get.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(walletId: string, xApiKey: string, options?: any) {
      return NonCustodialWalletAPIsApiFp(configuration).getWallet(walletId, xApiKey, options)(fetch, basePath);
    },
    /**
     * It returns a list of wallets for a company.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {string} [lastId] - The lastId is the last wallet id that was returned in the previous request. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(xApiKey: string, lastId?: string, size?: number, options?: any) {
      return NonCustodialWalletAPIsApiFp(configuration).listWallets(xApiKey, lastId, size, options)(fetch, basePath);
    },
  };
};

/**
 * NonCustodialWalletAPIsApi - object-oriented interface
 * @export
 * @class NonCustodialWalletAPIsApi
 * @extends {BaseAPI}
 */
export class NonCustodialWalletAPIsApi extends BaseAPI {
  /**
   * It gets the wallets of a user.
   * @param {string} email - The email of the user you want to get the wallets for.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NonCustodialWalletAPIsApi
   */
  public getUserWallets(email: string, xApiKey: string, options?: any) {
    return NonCustodialWalletAPIsApiFp(this.configuration).getUserWallets(
      email,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * It gets the wallet info.
   * @param {string} walletId - The wallet id of the wallet you want to get.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NonCustodialWalletAPIsApi
   */
  public getWallet(walletId: string, xApiKey: string, options?: any) {
    return NonCustodialWalletAPIsApiFp(this.configuration).getWallet(
      walletId,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * It returns a list of wallets for a company.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {string} [lastId] - The lastId is the last wallet id that was returned in the previous request. This is used to paginate the results.
   * @param {number} [size] - number &#x3D; 50
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NonCustodialWalletAPIsApi
   */
  public listWallets(xApiKey: string, lastId?: string, size?: number, options?: any) {
    return NonCustodialWalletAPIsApiFp(this.configuration).listWallets(
      xApiKey,
      lastId,
      size,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * TokenDataApisApi - fetch parameter creator
 * @export
 */
export const TokenDataApisApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {ITokenData} body - ITokenData - This is the request body that is sent to the API.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokenData(body: ITokenData, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling createTokenData.');
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling createTokenData.',
        );
      }
      const localVarPath = `/token-data/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ITokenData' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} tokenDataId - The id of the token data you want to retrieve.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenDataForServer(tokenDataId: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'tokenDataId' is not null or undefined
      if (tokenDataId === null || tokenDataId === undefined) {
        throw new RequiredError(
          'tokenDataId',
          'Required parameter tokenDataId was null or undefined when calling getTokenDataForServer.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getTokenDataForServer.',
        );
      }
      const localVarPath = `/token-data/get`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tokenDataId !== undefined) {
        localVarQueryParameter['tokenDataId'] = tokenDataId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * It lists all the token data for a company.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {string} [lastId] - The last id of the last token data that was returned. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokenData(xApiKey: string, lastId?: string, size?: number, options: any = {}): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listTokenData.',
        );
      }
      const localVarPath = `/token-data/list`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
         * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
         * @param {IUpdateTokenData} body - IUpdateTokenData - This is the request body that is sent to
the API.
         * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateTokenData(body: IUpdateTokenData, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateTokenData.');
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling updateTokenData.',
        );
      }
      const localVarPath = `/token-data/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IUpdateTokenData' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TokenDataApisApi - functional programming interface
 * @export
 */
export const TokenDataApisApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {ITokenData} body - ITokenData - This is the request body that is sent to the API.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokenData(
      body: ITokenData,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseTokenData_> {
      const localVarFetchArgs = TokenDataApisApiFetchParamCreator(configuration).createTokenData(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} tokenDataId - The id of the token data you want to retrieve.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenDataForServer(
      tokenDataId: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseITokenData_> {
      const localVarFetchArgs = TokenDataApisApiFetchParamCreator(configuration).getTokenDataForServer(
        tokenDataId,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * It lists all the token data for a company.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {string} [lastId] - The last id of the last token data that was returned. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokenData(
      xApiKey: string,
      lastId?: string,
      size?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseIListTokenData_> {
      const localVarFetchArgs = TokenDataApisApiFetchParamCreator(configuration).listTokenData(
        xApiKey,
        lastId,
        size,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
         * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
         * @param {IUpdateTokenData} body - IUpdateTokenData - This is the request body that is sent to
the API.
         * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateTokenData(
      body: IUpdateTokenData,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseTokenData_> {
      const localVarFetchArgs = TokenDataApisApiFetchParamCreator(configuration).updateTokenData(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TokenDataApisApi - factory interface
 * @export
 */
export const TokenDataApisApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {ITokenData} body - ITokenData - This is the request body that is sent to the API.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokenData(body: ITokenData, xApiKey: string, options?: any) {
      return TokenDataApisApiFp(configuration).createTokenData(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} tokenDataId - The id of the token data you want to retrieve.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenDataForServer(tokenDataId: string, xApiKey: string, options?: any) {
      return TokenDataApisApiFp(configuration).getTokenDataForServer(tokenDataId, xApiKey, options)(fetch, basePath);
    },
    /**
     * It lists all the token data for a company.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {string} [lastId] - The last id of the last token data that was returned. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokenData(xApiKey: string, lastId?: string, size?: number, options?: any) {
      return TokenDataApisApiFp(configuration).listTokenData(xApiKey, lastId, size, options)(fetch, basePath);
    },
    /**
         * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
         * @param {IUpdateTokenData} body - IUpdateTokenData - This is the request body that is sent to
the API.
         * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateTokenData(body: IUpdateTokenData, xApiKey: string, options?: any) {
      return TokenDataApisApiFp(configuration).updateTokenData(body, xApiKey, options)(fetch, basePath);
    },
  };
};

/**
 * TokenDataApisApi - object-oriented interface
 * @export
 * @class TokenDataApisApi
 * @extends {BaseAPI}
 */
export class TokenDataApisApi extends BaseAPI {
  /**
   * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
   * @param {ITokenData} body - ITokenData - This is the request body that is sent to the API.
   * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenDataApisApi
   */
  public createTokenData(body: ITokenData, xApiKey: string, options?: any) {
    return TokenDataApisApiFp(this.configuration).createTokenData(body, xApiKey, options)(this.fetch, this.basePath);
  }

  /**
   * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
   * @param {string} tokenDataId - The id of the token data you want to retrieve.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenDataApisApi
   */
  public getTokenDataForServer(tokenDataId: string, xApiKey: string, options?: any) {
    return TokenDataApisApiFp(this.configuration).getTokenDataForServer(
      tokenDataId,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * It lists all the token data for a company.
   * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
   * @param {string} [lastId] - The last id of the last token data that was returned. This is used to paginate the results.
   * @param {number} [size] - number &#x3D; 50
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenDataApisApi
   */
  public listTokenData(xApiKey: string, lastId?: string, size?: number, options?: any) {
    return TokenDataApisApiFp(this.configuration).listTokenData(
      xApiKey,
      lastId,
      size,
      options,
    )(this.fetch, this.basePath);
  }

  /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {IUpdateTokenData} body - IUpdateTokenData - This is the request body that is sent to
the API.
     * @param {string} xApiKey - This is the API key that is generated when you create a new API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenDataApisApi
     */
  public updateTokenData(body: IUpdateTokenData, xApiKey: string, options?: any) {
    return TokenDataApisApiFp(this.configuration).updateTokenData(body, xApiKey, options)(this.fetch, this.basePath);
  }
}
/**
 * TokenDataGroupApisApi - fetch parameter creator
 * @export
 */
export const TokenDataGroupApisApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {ITokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokenGroupData(body: ITokenGroupData, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createTokenGroupData.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling createTokenGroupData.',
        );
      }
      const localVarPath = `/token-group-data/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ITokenGroupData' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} tokenGroupDataId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenGroupData(tokenGroupDataId: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'tokenGroupDataId' is not null or undefined
      if (tokenGroupDataId === null || tokenGroupDataId === undefined) {
        throw new RequiredError(
          'tokenGroupDataId',
          'Required parameter tokenGroupDataId was null or undefined when calling getTokenGroupData.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getTokenGroupData.',
        );
      }
      const localVarPath = `/token-group-data/get`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tokenGroupDataId !== undefined) {
        localVarQueryParameter['tokenGroupDataId'] = tokenGroupDataId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} xApiKey
     * @param {string} [lastId]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokenGroupData(xApiKey: string, lastId?: string, size?: number, options: any = {}): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listTokenGroupData.',
        );
      }
      const localVarPath = `/token-group-data/list`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {IUpdateTokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTokenGroupData(body: IUpdateTokenGroupData, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateTokenGroupData.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling updateTokenGroupData.',
        );
      }
      const localVarPath = `/token-group-data/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IUpdateTokenGroupData' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TokenDataGroupApisApi - functional programming interface
 * @export
 */
export const TokenDataGroupApisApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {ITokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokenGroupData(
      body: ITokenGroupData,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesTokenGroupData_> {
      const localVarFetchArgs = TokenDataGroupApisApiFetchParamCreator(configuration).createTokenGroupData(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} tokenGroupDataId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenGroupData(
      tokenGroupDataId: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIGetTokenGroupDataResp_> {
      const localVarFetchArgs = TokenDataGroupApisApiFetchParamCreator(configuration).getTokenGroupData(
        tokenGroupDataId,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} xApiKey
     * @param {string} [lastId]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokenGroupData(
      xApiKey: string,
      lastId?: string,
      size?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIListTokenGroupDataResp_> {
      const localVarFetchArgs = TokenDataGroupApisApiFetchParamCreator(configuration).listTokenGroupData(
        xApiKey,
        lastId,
        size,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {IUpdateTokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTokenGroupData(
      body: IUpdateTokenGroupData,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesTokenGroupData_> {
      const localVarFetchArgs = TokenDataGroupApisApiFetchParamCreator(configuration).updateTokenGroupData(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TokenDataGroupApisApi - factory interface
 * @export
 */
export const TokenDataGroupApisApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {ITokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTokenGroupData(body: ITokenGroupData, xApiKey: string, options?: any) {
      return TokenDataGroupApisApiFp(configuration).createTokenGroupData(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} tokenGroupDataId
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenGroupData(tokenGroupDataId: string, xApiKey: string, options?: any) {
      return TokenDataGroupApisApiFp(configuration).getTokenGroupData(
        tokenGroupDataId,
        xApiKey,
        options,
      )(fetch, basePath);
    },
    /**
     * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
     * @param {string} xApiKey
     * @param {string} [lastId]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTokenGroupData(xApiKey: string, lastId?: string, size?: number, options?: any) {
      return TokenDataGroupApisApiFp(configuration).listTokenGroupData(xApiKey, lastId, size, options)(fetch, basePath);
    },
    /**
     * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
     * @param {IUpdateTokenGroupData} body This is a token data creation request description.
     * @param {string} xApiKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTokenGroupData(body: IUpdateTokenGroupData, xApiKey: string, options?: any) {
      return TokenDataGroupApisApiFp(configuration).updateTokenGroupData(body, xApiKey, options)(fetch, basePath);
    },
  };
};

/**
 * TokenDataGroupApisApi - object-oriented interface
 * @export
 * @class TokenDataGroupApisApi
 * @extends {BaseAPI}
 */
export class TokenDataGroupApisApi extends BaseAPI {
  /**
   * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
   * @param {ITokenGroupData} body This is a token data creation request description.
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenDataGroupApisApi
   */
  public createTokenGroupData(body: ITokenGroupData, xApiKey: string, options?: any) {
    return TokenDataGroupApisApiFp(this.configuration).createTokenGroupData(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
   * @param {string} tokenGroupDataId
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenDataGroupApisApi
   */
  public getTokenGroupData(tokenGroupDataId: string, xApiKey: string, options?: any) {
    return TokenDataGroupApisApiFp(this.configuration).getTokenGroupData(
      tokenGroupDataId,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Gets the token data (minting data and metadata) saved. You can use this to update and show the data.
   * @param {string} xApiKey
   * @param {string} [lastId]
   * @param {number} [size]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenDataGroupApisApi
   */
  public listTokenGroupData(xApiKey: string, lastId?: string, size?: number, options?: any) {
    return TokenDataGroupApisApiFp(this.configuration).listTokenGroupData(
      xApiKey,
      lastId,
      size,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Create a new token data (minting data and metadata). It does not mint. Only stores the metadata. You can treat this like an nft template.
   * @param {IUpdateTokenGroupData} body This is a token data creation request description.
   * @param {string} xApiKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokenDataGroupApisApi
   */
  public updateTokenGroupData(body: IUpdateTokenGroupData, xApiKey: string, options?: any) {
    return TokenDataGroupApisApiFp(this.configuration).updateTokenGroupData(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * TokenTransferAPIsApi - fetch parameter creator
 * @export
 */
export const TokenTransferAPIsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
         * Generate transfer form to be signed on client for transferring NFT (tokenDataId) from one wallet to another wallet
         * @param {ICreateTokenTransfer} body - ICreateTokenTransfer - this is the request body that is
sent to the API.
         * @param {string} accessToken - The access token of the user who is making the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createTransferOrder(body: ICreateTokenTransfer, accessToken: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createTransferOrder.',
        );
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling createTransferOrder.',
        );
      }
      const localVarPath = `/token-transfer/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accessToken !== undefined && accessToken !== null) {
        localVarHeaderParameter['access-token'] = String(accessToken);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ICreateTokenTransfer' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
         * Accepts the signature and the transfer form and submits to blockchain for transferring NFT (tokenDataId) from one wallet to another wallet, and returns the transaction hash
         * @param {ISubmitTokenTransferString} body - ISubmitTokenTransferString - This is the
request object that is sent to the API.
         * @param {string} accessToken - The access token that was generated by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitTransferOrder(body: ISubmitTokenTransferString, accessToken: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling submitTransferOrder.',
        );
      }
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling submitTransferOrder.',
        );
      }
      const localVarPath = `/token-transfer/submit`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accessToken !== undefined && accessToken !== null) {
        localVarHeaderParameter['access-token'] = String(accessToken);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ISubmitTokenTransferString' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TokenTransferAPIsApi - functional programming interface
 * @export
 */
export const TokenTransferAPIsApiFp = function (configuration?: Configuration) {
  return {
    /**
         * Generate transfer form to be signed on client for transferring NFT (tokenDataId) from one wallet to another wallet
         * @param {ICreateTokenTransfer} body - ICreateTokenTransfer - this is the request body that is
sent to the API.
         * @param {string} accessToken - The access token of the user who is making the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createTransferOrder(
      body: ICreateTokenTransfer,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesICreateTokenTransferResp_> {
      const localVarFetchArgs = TokenTransferAPIsApiFetchParamCreator(configuration).createTransferOrder(
        body,
        accessToken,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
         * Accepts the signature and the transfer form and submits to blockchain for transferring NFT (tokenDataId) from one wallet to another wallet, and returns the transaction hash
         * @param {ISubmitTokenTransferString} body - ISubmitTokenTransferString - This is the
request object that is sent to the API.
         * @param {string} accessToken - The access token that was generated by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitTransferOrder(
      body: ISubmitTokenTransferString,
      accessToken: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesISubmitTokenTransferResp_> {
      const localVarFetchArgs = TokenTransferAPIsApiFetchParamCreator(configuration).submitTransferOrder(
        body,
        accessToken,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TokenTransferAPIsApi - factory interface
 * @export
 */
export const TokenTransferAPIsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
         * Generate transfer form to be signed on client for transferring NFT (tokenDataId) from one wallet to another wallet
         * @param {ICreateTokenTransfer} body - ICreateTokenTransfer - this is the request body that is
sent to the API.
         * @param {string} accessToken - The access token of the user who is making the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createTransferOrder(body: ICreateTokenTransfer, accessToken: string, options?: any) {
      return TokenTransferAPIsApiFp(configuration).createTransferOrder(body, accessToken, options)(fetch, basePath);
    },
    /**
         * Accepts the signature and the transfer form and submits to blockchain for transferring NFT (tokenDataId) from one wallet to another wallet, and returns the transaction hash
         * @param {ISubmitTokenTransferString} body - ISubmitTokenTransferString - This is the
request object that is sent to the API.
         * @param {string} accessToken - The access token that was generated by the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    submitTransferOrder(body: ISubmitTokenTransferString, accessToken: string, options?: any) {
      return TokenTransferAPIsApiFp(configuration).submitTransferOrder(body, accessToken, options)(fetch, basePath);
    },
  };
};

/**
 * TokenTransferAPIsApi - object-oriented interface
 * @export
 * @class TokenTransferAPIsApi
 * @extends {BaseAPI}
 */
export class TokenTransferAPIsApi extends BaseAPI {
  /**
     * Generate transfer form to be signed on client for transferring NFT (tokenDataId) from one wallet to another wallet
     * @param {ICreateTokenTransfer} body - ICreateTokenTransfer - this is the request body that is
sent to the API.
     * @param {string} accessToken - The access token of the user who is making the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenTransferAPIsApi
     */
  public createTransferOrder(body: ICreateTokenTransfer, accessToken: string, options?: any) {
    return TokenTransferAPIsApiFp(this.configuration).createTransferOrder(
      body,
      accessToken,
      options,
    )(this.fetch, this.basePath);
  }

  /**
     * Accepts the signature and the transfer form and submits to blockchain for transferring NFT (tokenDataId) from one wallet to another wallet, and returns the transaction hash
     * @param {ISubmitTokenTransferString} body - ISubmitTokenTransferString - This is the
request object that is sent to the API.
     * @param {string} accessToken - The access token that was generated by the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenTransferAPIsApi
     */
  public submitTransferOrder(body: ISubmitTokenTransferString, accessToken: string, options?: any) {
    return TokenTransferAPIsApiFp(this.configuration).submitTransferOrder(
      body,
      accessToken,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * WalletAuthAPIsApi - fetch parameter creator
 * @export
 */
export const WalletAuthAPIsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get access token and refresh token a wallet by signing into with twitch/youtube oauth
     * @param {IWalletAuth} body - IWalletAuth. This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exchangeToken(body: IWalletAuth, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError('body', 'Required parameter body was null or undefined when calling exchangeToken.');
      }
      const localVarPath = `/auth/exchange-token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IWalletAuth' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
         * Refresh access token of a wallet. To be called from client server.
         * @param {IRefreshToken} body - IRefreshToken - This is the request body that is sent to the
server.
         * @param {string} xApiKey - This is the API key that is generated when you created the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    refreshTokenFromClientServer(body: IRefreshToken, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling refreshTokenFromClientServer.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling refreshTokenFromClientServer.',
        );
      }
      const localVarPath = `/auth/refresh-token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IRefreshToken' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verify user on Glip backend for security. Get the access token provided on from exchange-token api  and send to glip backend at least once for a user to ensure that user exists.
     * @param {IVerifyToken} body
     * @param {string} xApiKey - This is the api key of the client server. client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUserFromClientServer(body: IVerifyToken, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling verifyUserFromClientServer.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling verifyUserFromClientServer.',
        );
      }
      const localVarPath = `/auth/verify-token`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'IVerifyToken' !== 'string' || localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletAuthAPIsApi - functional programming interface
 * @export
 */
export const WalletAuthAPIsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Get access token and refresh token a wallet by signing into with twitch/youtube oauth
     * @param {IWalletAuth} body - IWalletAuth. This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exchangeToken(
      body: IWalletAuth,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIWalletAuthResponse_> {
      const localVarFetchArgs = WalletAuthAPIsApiFetchParamCreator(configuration).exchangeToken(body, options);
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
         * Refresh access token of a wallet. To be called from client server.
         * @param {IRefreshToken} body - IRefreshToken - This is the request body that is sent to the
server.
         * @param {string} xApiKey - This is the API key that is generated when you created the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    refreshTokenFromClientServer(
      body: IRefreshToken,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesIRefreshTokenResponse_> {
      const localVarFetchArgs = WalletAuthAPIsApiFetchParamCreator(configuration).refreshTokenFromClientServer(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Verify user on Glip backend for security. Get the access token provided on from exchange-token api  and send to glip backend at least once for a user to ensure that user exists.
     * @param {IVerifyToken} body
     * @param {string} xApiKey - This is the api key of the client server. client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUserFromClientServer(
      body: IVerifyToken,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesBoolean_> {
      const localVarFetchArgs = WalletAuthAPIsApiFetchParamCreator(configuration).verifyUserFromClientServer(
        body,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WalletAuthAPIsApi - factory interface
 * @export
 */
export const WalletAuthAPIsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
  return {
    /**
     * Get access token and refresh token a wallet by signing into with twitch/youtube oauth
     * @param {IWalletAuth} body - IWalletAuth. This is a wallet creation request description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exchangeToken(body: IWalletAuth, options?: any) {
      return WalletAuthAPIsApiFp(configuration).exchangeToken(body, options)(fetch, basePath);
    },
    /**
         * Refresh access token of a wallet. To be called from client server.
         * @param {IRefreshToken} body - IRefreshToken - This is the request body that is sent to the
server.
         * @param {string} xApiKey - This is the API key that is generated when you created the client.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    refreshTokenFromClientServer(body: IRefreshToken, xApiKey: string, options?: any) {
      return WalletAuthAPIsApiFp(configuration).refreshTokenFromClientServer(body, xApiKey, options)(fetch, basePath);
    },
    /**
     * Verify user on Glip backend for security. Get the access token provided on from exchange-token api  and send to glip backend at least once for a user to ensure that user exists.
     * @param {IVerifyToken} body
     * @param {string} xApiKey - This is the api key of the client server. client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUserFromClientServer(body: IVerifyToken, xApiKey: string, options?: any) {
      return WalletAuthAPIsApiFp(configuration).verifyUserFromClientServer(body, xApiKey, options)(fetch, basePath);
    },
  };
};

/**
 * WalletAuthAPIsApi - object-oriented interface
 * @export
 * @class WalletAuthAPIsApi
 * @extends {BaseAPI}
 */
export class WalletAuthAPIsApi extends BaseAPI {
  /**
   * Get access token and refresh token a wallet by signing into with twitch/youtube oauth
   * @param {IWalletAuth} body - IWalletAuth. This is a wallet creation request description
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletAuthAPIsApi
   */
  public exchangeToken(body: IWalletAuth, options?: any) {
    return WalletAuthAPIsApiFp(this.configuration).exchangeToken(body, options)(this.fetch, this.basePath);
  }

  /**
     * Refresh access token of a wallet. To be called from client server.
     * @param {IRefreshToken} body - IRefreshToken - This is the request body that is sent to the
server.
     * @param {string} xApiKey - This is the API key that is generated when you created the client.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletAuthAPIsApi
     */
  public refreshTokenFromClientServer(body: IRefreshToken, xApiKey: string, options?: any) {
    return WalletAuthAPIsApiFp(this.configuration).refreshTokenFromClientServer(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Verify user on Glip backend for security. Get the access token provided on from exchange-token api  and send to glip backend at least once for a user to ensure that user exists.
   * @param {IVerifyToken} body
   * @param {string} xApiKey - This is the api key of the client server. client.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletAuthAPIsApi
   */
  public verifyUserFromClientServer(body: IVerifyToken, xApiKey: string, options?: any) {
    return WalletAuthAPIsApiFp(this.configuration).verifyUserFromClientServer(
      body,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * WalletBalanceAPIsApi - fetch parameter creator
 * @export
 */
export const WalletBalanceAPIsApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This function returns the balance of a test ERC20 token for a given wallet
     * @param {string} walletId - The walletId of the wallet you want to get the balance of.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestErc20Balance(walletId: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling getTestErc20Balance.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getTestErc20Balance.',
        );
      }
      const localVarPath = `/wallet-balance/test-erc20`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * It gets the balance of a wallet.
     * @param {string} walletId - The walletId of the wallet you want to get the balance of.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance(walletId: string, xApiKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'walletId' is not null or undefined
      if (walletId === null || walletId === undefined) {
        throw new RequiredError(
          'walletId',
          'Required parameter walletId was null or undefined when calling getWalletBalance.',
        );
      }
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling getWalletBalance.',
        );
      }
      const localVarPath = `/wallet-balance/native`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This function returns a list of NFTs for a given wallet
     * @param {string} accessToken - The access token for the user.
     * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
     * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
     * @param {string} [lastId] - The lastId is the id of the last token that was returned in the previous call. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNFTsForWalletForClient(
      accessToken: string,
      walletId?: string,
      tokenDataIds?: Array<ObjectId>,
      lastId?: string,
      size?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'accessToken' is not null or undefined
      if (accessToken === null || accessToken === undefined) {
        throw new RequiredError(
          'accessToken',
          'Required parameter accessToken was null or undefined when calling listNFTsForWalletForClient.',
        );
      }
      const localVarPath = `/wallet-balance/list-wallet-nft-client`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (tokenDataIds) {
        localVarQueryParameter['tokenDataIds'] = tokenDataIds;
      }

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (accessToken !== undefined && accessToken !== null) {
        localVarHeaderParameter['access-token'] = String(accessToken);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This function returns a list of all the NFTs that a user owns
     * @param {string} xApiKey - This is the API key that you will get from the admin panel.
     * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
     * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
     * @param {string} [lastId] - This is the last id of the last token that was returned in the previous call. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNFTsForWalletForServer(
      xApiKey: string,
      walletId?: string,
      tokenDataIds?: Array<ObjectId>,
      lastId?: string,
      size?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'xApiKey' is not null or undefined
      if (xApiKey === null || xApiKey === undefined) {
        throw new RequiredError(
          'xApiKey',
          'Required parameter xApiKey was null or undefined when calling listNFTsForWalletForServer.',
        );
      }
      const localVarPath = `/wallet-balance/list-wallet-nft-server`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (walletId !== undefined) {
        localVarQueryParameter['walletId'] = walletId;
      }

      if (tokenDataIds) {
        localVarQueryParameter['tokenDataIds'] = tokenDataIds;
      }

      if (lastId !== undefined) {
        localVarQueryParameter['lastId'] = lastId;
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size;
      }

      if (xApiKey !== undefined && xApiKey !== null) {
        localVarHeaderParameter['x-api-key'] = String(xApiKey);
      }

      localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WalletBalanceAPIsApi - functional programming interface
 * @export
 */
export const WalletBalanceAPIsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This function returns the balance of a test ERC20 token for a given wallet
     * @param {string} walletId - The walletId of the wallet you want to get the balance of.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestErc20Balance(
      walletId: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesWalletBalanceArray_> {
      const localVarFetchArgs = WalletBalanceAPIsApiFetchParamCreator(configuration).getTestErc20Balance(
        walletId,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * It gets the balance of a wallet.
     * @param {string} walletId - The walletId of the wallet you want to get the balance of.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance(
      walletId: string,
      xApiKey: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesWalletBalance_> {
      const localVarFetchArgs = WalletBalanceAPIsApiFetchParamCreator(configuration).getWalletBalance(
        walletId,
        xApiKey,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This function returns a list of NFTs for a given wallet
     * @param {string} accessToken - The access token for the user.
     * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
     * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
     * @param {string} [lastId] - The lastId is the id of the last token that was returned in the previous call. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNFTsForWalletForClient(
      accessToken: string,
      walletId?: string,
      tokenDataIds?: Array<ObjectId>,
      lastId?: string,
      size?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseIListUsersTokens_> {
      const localVarFetchArgs = WalletBalanceAPIsApiFetchParamCreator(configuration).listNFTsForWalletForClient(
        accessToken,
        walletId,
        tokenDataIds,
        lastId,
        size,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This function returns a list of all the NFTs that a user owns
     * @param {string} xApiKey - This is the API key that you will get from the admin panel.
     * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
     * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
     * @param {string} [lastId] - This is the last id of the last token that was returned in the previous call. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNFTsForWalletForServer(
      xApiKey: string,
      walletId?: string,
      tokenDataIds?: Array<ObjectId>,
      lastId?: string,
      size?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponsesResponseIListUsersTokens_> {
      const localVarFetchArgs = WalletBalanceAPIsApiFetchParamCreator(configuration).listNFTsForWalletForServer(
        xApiKey,
        walletId,
        tokenDataIds,
        lastId,
        size,
        options,
      );
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WalletBalanceAPIsApi - factory interface
 * @export
 */
export const WalletBalanceAPIsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * This function returns the balance of a test ERC20 token for a given wallet
     * @param {string} walletId - The walletId of the wallet you want to get the balance of.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTestErc20Balance(walletId: string, xApiKey: string, options?: any) {
      return WalletBalanceAPIsApiFp(configuration).getTestErc20Balance(walletId, xApiKey, options)(fetch, basePath);
    },
    /**
     * It gets the balance of a wallet.
     * @param {string} walletId - The walletId of the wallet you want to get the balance of.
     * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance(walletId: string, xApiKey: string, options?: any) {
      return WalletBalanceAPIsApiFp(configuration).getWalletBalance(walletId, xApiKey, options)(fetch, basePath);
    },
    /**
     * This function returns a list of NFTs for a given wallet
     * @param {string} accessToken - The access token for the user.
     * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
     * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
     * @param {string} [lastId] - The lastId is the id of the last token that was returned in the previous call. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNFTsForWalletForClient(
      accessToken: string,
      walletId?: string,
      tokenDataIds?: Array<ObjectId>,
      lastId?: string,
      size?: number,
      options?: any,
    ) {
      return WalletBalanceAPIsApiFp(configuration).listNFTsForWalletForClient(
        accessToken,
        walletId,
        tokenDataIds,
        lastId,
        size,
        options,
      )(fetch, basePath);
    },
    /**
     * This function returns a list of all the NFTs that a user owns
     * @param {string} xApiKey - This is the API key that you will get from the admin panel.
     * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
     * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
     * @param {string} [lastId] - This is the last id of the last token that was returned in the previous call. This is used to paginate the results.
     * @param {number} [size] - number &#x3D; 50,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNFTsForWalletForServer(
      xApiKey: string,
      walletId?: string,
      tokenDataIds?: Array<ObjectId>,
      lastId?: string,
      size?: number,
      options?: any,
    ) {
      return WalletBalanceAPIsApiFp(configuration).listNFTsForWalletForServer(
        xApiKey,
        walletId,
        tokenDataIds,
        lastId,
        size,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * WalletBalanceAPIsApi - object-oriented interface
 * @export
 * @class WalletBalanceAPIsApi
 * @extends {BaseAPI}
 */
export class WalletBalanceAPIsApi extends BaseAPI {
  /**
   * This function returns the balance of a test ERC20 token for a given wallet
   * @param {string} walletId - The walletId of the wallet you want to get the balance of.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletBalanceAPIsApi
   */
  public getTestErc20Balance(walletId: string, xApiKey: string, options?: any) {
    return WalletBalanceAPIsApiFp(this.configuration).getTestErc20Balance(
      walletId,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * It gets the balance of a wallet.
   * @param {string} walletId - The walletId of the wallet you want to get the balance of.
   * @param {string} xApiKey - This is the API key that you will use to authenticate your requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletBalanceAPIsApi
   */
  public getWalletBalance(walletId: string, xApiKey: string, options?: any) {
    return WalletBalanceAPIsApiFp(this.configuration).getWalletBalance(
      walletId,
      xApiKey,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * This function returns a list of NFTs for a given wallet
   * @param {string} accessToken - The access token for the user.
   * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
   * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
   * @param {string} [lastId] - The lastId is the id of the last token that was returned in the previous call. This is used to paginate the results.
   * @param {number} [size] - number &#x3D; 50,
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletBalanceAPIsApi
   */
  public listNFTsForWalletForClient(
    accessToken: string,
    walletId?: string,
    tokenDataIds?: Array<ObjectId>,
    lastId?: string,
    size?: number,
    options?: any,
  ) {
    return WalletBalanceAPIsApiFp(this.configuration).listNFTsForWalletForClient(
      accessToken,
      walletId,
      tokenDataIds,
      lastId,
      size,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * This function returns a list of all the NFTs that a user owns
   * @param {string} xApiKey - This is the API key that you will get from the admin panel.
   * @param {string} [walletId] - The walletId of the wallet you want to get the NFTs for.
   * @param {Array<ObjectId>} [tokenDataIds] - ObjectId[] &#x3D; [] as ObjectId[] as in mongose ids of the tokens.
   * @param {string} [lastId] - This is the last id of the last token that was returned in the previous call. This is used to paginate the results.
   * @param {number} [size] - number &#x3D; 50,
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletBalanceAPIsApi
   */
  public listNFTsForWalletForServer(
    xApiKey: string,
    walletId?: string,
    tokenDataIds?: Array<ObjectId>,
    lastId?: string,
    size?: number,
    options?: any,
  ) {
    return WalletBalanceAPIsApiFp(this.configuration).listNFTsForWalletForServer(
      xApiKey,
      walletId,
      tokenDataIds,
      lastId,
      size,
      options,
    )(this.fetch, this.basePath);
  }
}
